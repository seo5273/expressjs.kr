<!DOCTYPE html><html><head><title>Express - api reference</title><link rel="stylesheet" href="/style.css"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Open+Sans:300,400,600,700&amp;amp;subset=latin,latin-ext"><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><script src="http://ajax.googleapis.com/ajax/libs/jquery/1.11.0/jquery.min.js"></script><script src="/app.js"></script><script src="/retina.js"></script></head><body class="inner"><div class="bar"></div><section id="content"><header><section id="logo"><a href="/" class="express">express</a><span class="description"><a href="http://nodejs.org">node</a>를 위한 웹 애플리케이션 프레임워크</span></section><nav class="clearfix"><a href="/">Home</a><a href="/4x/api.html" class="active">API Reference</a><a href="/guide.html">Guide</a><a href="/applications.html">Applications</a><a href="/community.html">Community</a><a href="/faq.html">FAQ</a><a href="http://expressjs.com/3x/api.html">3.x 문서</a></nav></header><ul id="menu"><li id="app-api"><a href="#express">Application</a><ul id="app-menu"><li><a href="#express">express()</a></li><li><a href="#app-settings">application settings</a></li><li><a href="#app.set">app.set()</a></li><li><a href="#app.get">app.get()</a></li><li><a href="#app.enable">app.enable()</a></li><li><a href="#app.disable">app.disable()</a></li><li><a href="#app.enabled">app.enabled()</a></li><li><a href="#app.disabled">app.disabled()</a></li><li><a href="#app.use">app.use()</a></li><li><a href="#app.engine">app.engine()</a></li><li><a href="#app.param">app.param()</a></li><li><a href="#app.VERB">application routing</a></li><li><a href="#app.all">app.all()</a></li><li><a href="#app.route">app.route()</a></li><li><a href="#app.locals">app.locals</a></li><li><a href="#app.render">app.render()</a></li><li><a href="#app.listen">app.listen()</a></li></ul></li><li id="req-api"><a href="#req.params">Request</a><ul id="req-menu"><li><a href="#req.params">req.params</a></li><li><a href="#req.query">req.query</a></li><li><a href="#req.param">req.param()</a></li><li><a href="#req.route">req.route</a></li><li><a href="#req.cookies">req.cookies</a></li><li><a href="#req.signedCookies">req.signedCookies</a></li><li><a href="#req.get">req.get()</a></li><li><a href="#req.accepts">req.accepts()</a></li><li><a href="#req.acceptsCharset">req.acceptsCharset()</a></li><li><a href="#req.acceptsLanguage">req.acceptsLanguage()</a></li><li><a href="#req.is">req.is()</a></li><li><a href="#req.ip">req.ip</a></li><li><a href="#req.ips">req.ips</a></li><li><a href="#req.path">req.path</a></li><li><a href="#req.host">req.host</a></li><li><a href="#req.fresh">req.fresh</a></li><li><a href="#req.stale">req.stale</a></li><li><a href="#req.xhr">req.xhr</a></li><li><a href="#req.protocol">req.protocol</a></li><li><a href="#req.secure">req.secure</a></li><li><a href="#req.subdomains">req.subdomains</a></li><li><a href="#req.originalUrl">req.originalUrl</a></li></ul></li><li id="res-api"><a href="#res.status">Response</a><ul id="res-menu"><li><a href="#res.status">res.status()</a></li><li><a href="#res.set">res.set()</a></li><li><a href="#res.get">res.get()</a></li><li><a href="#res.cookie">res.cookie()</a></li><li><a href="#res.clearCookie">res.clearCookie()</a></li><li><a href="#res.redirect">res.redirect()</a></li><li><a href="#res.location">res.location()</a></li><li><a href="#res.send">res.send()</a></li><li><a href="#res.json">res.json()</a></li><li><a href="#res.jsonp">res.jsonp()</a></li><li><a href="#res.type">res.type()</a></li><li><a href="#res.format">res.format()</a></li><li><a href="#res.attachment">res.attachment()</a></li><li><a href="#res.sendfile">res.sendfile()</a></li><li><a href="#res.download">res.download()</a></li><li><a href="#res.links">res.links()</a></li><li><a href="#res.locals">res.locals</a></li><li><a href="#res.render">res.render()</a></li></ul></li><li id="router-api"><a href="#router">Router</a><ul id="router-menu"><li><a href="#router">Router()</a></li><li><a href="#router.use">router.use()</a></li><li><a href="#router.param">router.param()</a></li><li><a href="#router.route">router.route()</a></li><li><a href="#router.VERB">router.VERB()</a></li></ul></li><li id="middleware-api"><a href="#middleware">Middleware</a><ul id="middleware-menu"><li><a href="#basicAuth">basicAuth()</a></li><li><a href="#bodyParser">bodyParser()</a></li><li><a href="#compress">compress()</a></li><li><a href="#cookieParser">cookieParser()</a></li><li><a href="#cookieSession">cookieSession()</a></li><li><a href="#csrf">csrf()</a></li><li><a href="#directory">directory()</a></li></ul></li></ul><div id="right"><section><h3 id="express">express()</h3><p>express 애플리케이션을 생성합니다.
</p><pre class="js"><code>var express = require('express');
var app = express();

app.get('/', function(req, res){
  res.send('hello world');
});

app.listen(3000);</code></pre></section><h2>Application</h2><a name="application"></a><section><h3 id="app-settings">설정</h3><p>The following settings are provided to alter how Express will behave:
아래 설정들은 Express가 어떻게 행동하는 지를 수정하기 위한 것입니다.
</p><ul><li><code>env </code>환경 모드(environment mode). 기본 값은 <code>process.env.NODE_ENV</code> (NODE_ENV 환경 변수) 혹은 "development"</li><li><code>trust proxy </code>역 프록시(reverse proxy) 지원을 활성화 시키기. 기본 값은 비활성화.</li><li><code>jsonp callback name </code><code>?callback=</code>의 기본 콜백 이름 바꾸기. </li><li><code>json replacer </code>JASON의 대체 콜백. 기본 값은 null.</li><li><code>case sensitive routing </code>대소문자 구분 활성화 시키기. 기본 값은 비활성화로, "/Foo"와 "/foo"를 같은 것으로 취급한다.</li><li><code>strict routing </code>엄격한 라우팅(Strict routing)을 활성화 시키기. 기본적으로 라우터는 "/foo" and "/foo/"을 같은 것으로 취급힌다.</li><li><code>view cache </code>View template compilation caching을 활성화 시키기. 기본적으로 생산(production)에 활성화 되어있다.</li><li><code>view engine </code>기본 엔진 확장(engine extension).</li><li><code>views </code>View 디렉토리 경로. 기본 값은 "process.cwd() + '/views'"</li><li><code>x-powered-by </code><code>X-Powered-By: Express</code>의 HTTP 헤더를 활성화 시키기. 기본 값은 활성화.</li></ul></section><section><h3 id="app.set">app.set(name, value)</h3><p><code>name</code>을 <code>value</code>로 설정하여 할당합니다.
</p><pre class="js"><code>app.set('title', 'My Site');
app.get('title');
// => "My Site"</code></pre></section><section><h3 id="app.get">app.get(name)</h3><p>설정된 <code>name</code> 값을 불러옵니다.
</p><pre class="js"><code>app.get('title');
// => undefined

app.set('title', 'My Site');
app.get('title');
// => "My Site"</code></pre></section><section><h3 id="app.enable">app.enable(name)</h3><p><code>name</code>을 <code>true</code>로 설정합니다.
</p><pre class="js"><code>app.enable('trust proxy');
app.get('trust proxy');
// => true</code></pre></section><section><h3 id="app.disable">app.disable(name)</h3><p><code>name</code>을 <code>false</code>로 설정합니다.
</p><pre class="js"><code>app.disable('trust proxy');
app.get('trust proxy');
// => false</code></pre></section><section><h3 id="app.enabled">app.enabled(name)</h3><p><code>name</code>설정이 활성화 되어 있는 지 검사합니다.
</p><pre class="js"><code>app.enabled('trust proxy');
// => false

app.enable('trust proxy');
app.enabled('trust proxy');
// => true</code></pre></section><section><h3 id="app.disabled">app.disabled(name)</h3><p><code>name</code>가 비활성화 되어 있는 지 확인합니다.
</p><pre class="js"><code>app.disabled('trust proxy');
// => true

app.enable('trust proxy');
app.disabled('trust proxy');
// => false</code></pre></section><section><h3 id="app.use">app.use([path], function)</h3><p>주어진 middleware <code>function</code>와 선택적 마운트(optional mount) <code>path</code>를 사용합니다.
기본 값은 "/"입니다.
</p><pre class="js"><code>var express = require('express');
var app = express();

// simple logger
app.use(function(req, res, next){
  console.log('%s %s', req.method, req.url);
  next();
});

// respond
app.use(function(req, res, next){
  res.send('Hello World');
});

app.listen(3000);
</code></pre><p>"마운트" 경로는 stripped되어 있으며, 미들웨어 <code>function</code>에서 <strong>보이지 않습니다.</strong>
이 것의 가장 큰 특징은 마운트 된 미들웨어는 "prefix"의 경로 이름에 관계 없이 코드의 수정 없이도
작동 할 수 있다는 것입니다.  
</p><p>아래의 예제는 <code>express.static()</code> 미들웨어를 사용하여
./public 안의 사용 파일(serving file)의 전형적인 Use-case(typical use-case)를 받습니다.  
</p><pre class="js"><code>// GET /javascripts/jquery.js
// GET /style.css
// GET /favicon.ico
app.use(express.static(__dirname + '/public'));
</code></pre><p>예를 들어, 모든 정적 파일에 "/static"이라고 prefix를 하고 싶다면, "마운팅" 특징을 이용하여 지원 할 수 있습니다.
마운트 된 미들웨어 함수는 함수가 호출 되어 있을 때 stripped 되어 있지 않은 상태의
<code>req.url</code>가 이 prefix를 포함하고 있지 않으면 <strong>호출 되지 않습니다.</strong>

이 것은 함수에만 영향을 끼치며, 그 이후 미들웨어는 마운트 되지 않은 이상 "/static"이 포함된 <code>req.url</code>를
볼 수 있습니다. 
</p><pre class="js"><code>// GET /static/javascripts/jquery.js
// GET /static/style.css
// GET /static/favicon.ico
app.use('/static', express.static(__dirname + '/public'));
</code></pre><p><code>app.use()</code>을 사용하여 "정의 된" 미들웨어의 순서는 매우 중요하며, 미들웨어는 순서대로 호출됩니다.
그러므로 이 것은 미들웨어의 우선순위를 정의합니다.
예를 들어, 대체로 로깅 미들웨어는 다른 미들웨어 보다 가장 먼저 나옵니다.
</p><pre class="js"><code>var logger = require('morgan');

app.use(logger());
app.use(express.static(__dirname + '/public'));
app.use(function(req, res){
  res.send('Hello');
});
</code></pre><p>만약 정적 파일을 위한 로깅 요청을 무시하고, <code>logger()</code> 후에 로깅 라우트나 미들웨어 정의를 계속 하고 싶다면,
위의 <code>static()</code>로 이동하세요.
</p><pre class="js"><code>app.use(express.static(__dirname + '/public'));
app.use(logger());
app.use(function(req, res){
  res.send('Hello');
});
</code></pre><p>다른 예제는 여러 디렉토리의 사용 파일(serving files)가 다른 것들보다 "./public"에 우선순위를 주는 것입니다.
</p><pre class="js"><code>app.use(express.static(__dirname + '/public'));
app.use(express.static(__dirname + '/files'));
app.use(express.static(__dirname + '/uploads'));</code></pre></section><section><h3 id="app.engine">app.engine(ext, callback)</h3><p>주어진 템플릿 엔진(template engine) <code>callback</code>을 <code>ext</code>로 등록합니다.
기본 값은 파일 확장자에 기반한 엔진을 필요로 합니다.
예를 들어, "foo.jade"파일을 만들 때(render), Express는 내부적으로 아래를 호출하며,
성능을 증가시키기 위해 이후의 콜들의 <code>require()</code>을 캐싱합니다.
</p><pre class="js"><code>app.engine('jade', require('jade').__express);
</code></pre><p>Box 외부의 <code>.__express</code>를 제공 하지 않는 엔진이나, 혹은
다른 확장을 (different extension) 템플릿 엔진(template engine)으로 맵핑(map) 시키고 싶다면,
이 방법을 이용하세요. 예를 들어 EJS 템플릿 엔진을 ".html" files:로 맵핑 시킬 때는,
</p><pre class="js"><code>app.engine('html', require('ejs').renderFile);
</code></pre><p>이런 경우에는 Express가 기대하는 <code>(path, options, callback)</code> 같은 서명을 가진 
<code>.renderFile()</code> 메소드를 제공합니다.

그러나 이 메소드는 내부적으로 <code>ejs.__express</code>라고 불려지고, ".ejs"확장자를 사용한다면
아무 것도 하지 않아도 된다는 걸 알아두세요. 
</p><p>어떤 템플릿 엔진(template engines)는 이러한 방식을 따르지 않습니다. 
<a href="https://github.com/visionmedia/consolidate.js">consolidate.js</a>
라이브러리는 모든 노드의 널리 쓰이는 템플릿 엔진이 이러한 방식을 따르도록 맵핑 시키기 위해 만들어졌고,
이 때문에 Express 안에 비슷하게 사용됩니다.
</p><pre class="js"><code>var engines = require('consolidate');
app.engine('haml', engines.haml);
app.engine('html', engines.hogan);</code></pre></section><section><h3 id="app.param">app.param([name], callback)</h3><p>로직(logic)을 라우트 파라미터로 맵핑합니다.
예를 들어, <code>:user</code>가 라우트 경로에 있을 때, 
자동적으로 <code>req.user</code>을 자동적으로 제공하기 위해서 유저 로딩 로직(user loading logic)을
루트로 맵핑하거나, 파라미터의 입력값의 유효성을 검사 할 수 있습니다. 
</p><p>아래는 <code>callback</code>가 얼마나 미들웨어랑 비슷한 지를 보여줍니다.
그러므로 아래는 비동기 오퍼레이션(async operations)을 지원하고 파라미터의 부가적인 값(여기서는 <code>id</code>)들을 
제공하는 것을 보여줍니다.  
User을 불러오는 것이 시도가 실행 되었고, <code>req.user</code>를 할당합니다. 그렇지 않으면 에러를 <code>next(err)</code>로 넘깁니다. 

</p><pre class="js"><code>app.param('user', function(req, res, next, id){
  User.find(id, function(err, user){
    if (err) {
      next(err);
    } else if (user) {
      req.user = user;
      next();
    } else {
      next(new Error('failed to load user'));
    }
  });
});
</code></pre><p>다른 방법으론, <code>callback</code>만 넘기는 방법이 있는데, 이 경우에는 <code>app.param()</code> API를
변경 할 수 있습니다.
예를 들어, <a href="http://github.com/visionmedia/express-params">express-params</a>는
아래 주어진 정규식으로 파라미터를 제한 할 수 있는 콜백을 정의 해 줍니다.
</p><p>아래 예제는 두 번째 argument가 정규식인지 확인하고, "user" param 예제 같은 역할의 콜백을 반환해주는 것을 보여주는 응용 예제 입니다.
</p><pre class="js"><code>app.param(function(name, fn){
  if (fn instanceof RegExp) {
    return function(req, res, next, val){
      var captures;
      if (captures = fn.exec(String(val))) {
        req.params[name] = captures;
        next();
      } else {
        next('route');
      }
    }
  }
});
</code></pre><p>이 메소드는 파라미터들의 유효성 검사나 캡쳐 그룹(capture groups)을 제공하기 위해 파싱 할 때 효과적으로 쓰입니다.
</p><pre class="js"><code>app.param('id', /^\d+$/);

app.get('/user/:id', function(req, res){
  res.send('user ' + req.params.id);
});

app.param('range', /^(\w+)\.\.(\w+)?$/);

app.get('/range/:range', function(req, res){
  var range = req.params.range;
  res.send('from ' + range[1] + ' to ' + range[2]);
});</code></pre></section><section><h3 id="app.VERB">app.VERB(path, [callback...], callback)</h3><p><code>app.VERB()</code> 메소드는 Express 안의 <code>app.post()</code>과 같은
HTTP verb 중 하나인 <strong>VERB</strong>의 라우팅 기능을 제공합니다. 
똑같이 취급되는 여러 콜백들이 주어지고, 미들웨어 같은 역할을 합니다.
남은 루트 콜백들을 우회하기 위하여 
한 예외를 제외하고는 이 콜백들은 <code>next('route')</code>를 호출합니다. 
with the route matched.
이 방법은 사전 조건을 수행하기 위해여 루트에 쓰일 수 있으며, 매치되는 루트에 계속 진행 할 이유가 없어 질 때에
이후 루트들에 통제권을 넘깁니다. 
</p><p>아래는 가능한 가장 단순한 루트 정의를 보여줍니다.
Express는 path 문자열을 정규식으로 변환 시켜주며, 내부적으로 새로 들어오는 요청을 매치시키기 위하여 사용됩니다. 
쿼리 문자열은 이러한 매치를 수행하는 데 고려되지 <em>않습니다.</em>
예를 들어 "GET /"는 "GET /?name=tobi"처럼 다음 루트를 매칭시킵니다.    
</p><pre class="js"><code>app.get('/', function(req, res){
  res.send('hello world');
});
</code></pre><p>예를 들어 아래 "GET /commits/71dbb9c..4c084f9" 뿐만 아니라 "GET /commits/71dbb9c"가 매칭하는 것 처럼
특별한 통제가 필요할 경우 정규식 또한 유용하게 사용 될 수 있습니다.
</p><pre class="js"><code>app.get(/^\/commits\/(\w+)(?:\.\.(\w+))?$/, function(req, res){
  var from = req.params[0];
  var to = req.params[1] || 'HEAD';
  res.send('commit range ' + from + '..' + to);
});
</code></pre><p>여러 콜백을 넘기고, 리소스를 불러오는 미들웨어를 다시 사용 하는 데에 유용하며, 유효성 검사 등을 수행합니다.
</p><pre class="js"><code>app.get('/user/:id', user.load, function(){
  // ... 
})
</code></pre><p>루트 하나에 여러 공동 미들웨어가 있다면, <code>all</code>를 이용하여 루트 API를 사용 할 수 있습니다.
</p><pre class="js"><code>var middleware = [loadForum, loadThread];

app.route('/forum/:fid/thread/:tid')
.all(loadForum)
.all(loadThread)
.get(function() { //... });
.post(function() { //... });
</code></pre><p>GET and POST 요청을 위해 두 미들웨어가 수행됩니다. </p></section><section><h3 id="app.all">app.all(path, [callback...], callback)</h3><p>이 메소드는 <code>app.VERB()</code> 메소드와 같은 기능을 하지만, 모든 HTTP verb를 매칭 시킨다는 점이 다릅니다. 
</p><p>이 메소드는 경로 prefix나 임의 매칭을 위한 "전역" 논리를 맵핑 할 때 특히 매우 유용합니다. 

예를 들어, 다음 루트를 다른 모든 루트 정의 위에 둔다면, 어떤 지점 부터의 모든 루트 들은
인증을 필요로 하며 자동적으로 유저를 불러옵니다. 

이러한 콜백들은 end point 같은 역할을 하지 않으며, 
<code>loadUser</code>가 task를 수행하고, <code>next()</code>가 다음의 루트들을 계속하여 매칭시킨다는 것을 알아두세요.
</p><pre class="js"><code>app.all('*', requireAuthentication, loadUser);
</code></pre><p>혹은, 
</p><pre class="js"><code>app.all('*', requireAuthentication)
app.all('*', loadUser);
</code></pre><p>또 다른 좋은 예제는 white-listed "전역" 기능입니다. 
여기의 예제는 앞의 것과 비슷하지만 오직 "/api"의 prefix된 경로만을 통제 합니다. 
</p><pre class="js"><code>app.all('/api/*', requireAuthentication);</code></pre></section><section><h3 id="app.route">app.route(path)</h3><p>선택적 미들웨어와 HTTP verb를 다루기 위한 싱글 루트 인스턴스를 반환합니다.
중복되는 루트 이름과 오타에서 나오는 에러들을 막기 위해 <code>app.route()</code>를 사용한 접근 방법이 추천됩니다.
</p><pre class="js"><code>var app = express();

app.route('/events')
.all(function(req, res, next) {
  // runs for all HTTP verbs first
  // think of it as route specific middleware!
})
.get(function(req, res, next) {
  res.json(...);
})
.post(function(req, res, next) {
  // maybe add a new event...
})
</code></pre></section><section><h3 id="app.locals">app.locals</h3><p>애플리케이션 안에 만들어진 모든 템플릿에 애플리케이션의 지역 변수를 제공합니다. 
애플리케이션 레벨의 데이터나 템플릿의 helper 함수를 제공 할 때 특히 유용합니다.
</p><pre class="js"><code>app.locals.title = 'My App';
app.locals.strftime = require('strftime');
app.locals.email = 'me@myapp.com';
</code></pre><p><code>app.locals</code> 오브젝트는 자바스크립트 <code>Object</code>입니다. 
여기에 부여 된 속성은 애플리케이션 안의 지역 변수로서 노출됩니다.
</p><pre class="js"><code>app.locals.title
// => 'My App'

app.locals.email
// => 'me@myapp.com'
</code></pre><p>기본적으로 Express는 오직 싱글 애플리케이션 레벨의 지역 변수인 <code>settings</code>만 노출시킵니다.  
</p><pre class="js"><code>app.set('title', 'My App');
// use settings.title in a view</code></pre></section><section><h3 id="app.render">app.render(view, [options], callback)</h3><p>. 
<code>view</code>과 생성된 문자열에 결과를 나타내는 콜백을 생성합니다.
이 것은 <code>res.render()</code>을 애플리케이션 레벨에서 사용하는 방법이며, 
기본적으로 같은 역할을 합니다. </p><pre class="js"><code>app.render('email', function(err, html){
  // ...
});

app.render('email', { name: 'Tobi' }, function(err, html){
  // ...
});</code></pre></section><section><h3 id="app.listen">app.listen()</h3><p>주어진 호스트와 포트 연결을 bind하고 listen합니다.
이 메소드는 노드의 <a href="http://nodejs.org/api/http.html#http_server_listen_port_hostname_backlog_callback">http.Server#listen()</a>와
동일합니다.
</p><pre class="js"><code>var express = require('express');
var app = express();
app.listen(3000);
</code></pre><p><code>express()</code>에 의해 반환되는 <code>app</code>은 
요청을 처리하기 위한 콜백으로서, 노드의 http 서버로 넘기기 위해 디자인 된 자바스크립트의 <code>Function</code>이며,
이는 당신의 HTTP와 HTTPS 버전의 앱 둘다 같은 코드베이스를 쉽게 제공하게 도와주며, 이 앱은 그 들로 부터 상속하지 않는
단순한 콜백입니다.
</p><pre class="js"><code>var express = require('express');
var https = require('https');
var http = require('http');
var app = express();

http.createServer(app).listen(80);
https.createServer(options, app).listen(443);
</code></pre><p><code>app.listen()</code> 메소드는 단순히 편리하게 정의된 메소드이며,
HTTPS를 사용하거나 둘 다 제공하기 위해서는 위의 방법들을 사용하세요.
</p><pre class="js"><code>app.listen = function(){
  var server = http.createServer(this);
  return server.listen.apply(server, arguments);
};</code></pre></section><h2>Request</h2><a name="request"></a><section><h3 id="req.params">req.params</h3><p>이 속성은 "parameters" 루트에 맵핑되는 속성들을 포함하는 오브젝트 입니다.
예를 들어, <code>/user/:name</code>를 가질 때, "name" 속성은 <code>req.params.name</code>로서 사용 가능합니다.
이 속성의 기본 값은 <code>{}</code>입니다.
</p><pre class="js"><code>// GET /user/tj
req.params.name
// => "tj"
</code></pre><p>When a regular expression is used for the route definition, 
정규식이 루트 정의를 위해 사용 될 때, <code>req.params[N]</code>를 사용한 배열에 캡쳐 그룹(capture groups)이 제공되고,
<code>N</code>은 캡쳐 그룹의 n번째를 의미합니다.
이 규칙은 이름이 정의되지 않은 와일드 카드 매치와 `/file/*`과 같은 문자열 루트에 적용됩니다.
</p><pre class="js"><code>// GET /file/javascripts/jquery.js
req.params[0]
// => "javascripts/jquery.js"</code></pre></section><section><h3 id="req.query">req.query</h3><p>이 속성은 파싱 된 쿼리 문자열을 포함하고 있는 오브젝트이며, 기본 값은 <code>{}</code>입니다.
</p><pre class="js"><code>// GET /search?q=tobi+ferret
req.query.q
// => "tobi ferret"

// GET /shoes?order=desc&shoe[color]=blue&shoe[type]=converse
req.query.order
// => "desc"

req.query.shoe.color
// => "blue"

req.query.shoe.type
// => "converse"</code></pre></section><section><h3 id="req.param">req.param(name)</h3><p>param <code>name</code>의 값이 존재 하는 경우 반환합니다.
</p><pre class="js"><code>// ?name=tobi
req.param('name')
// => "tobi"

// POST name=tobi
req.param('name')
// => "tobi"

// /user/tobi for /user/:name 
req.param('name')
// => "tobi"
</code></pre><p>Lookup이 다음과 같은 순서로 수행됩니다.</p><ul><li><code>req.params</code></li><li><code>req.body</code></li><li><code>req.query</code></li></ul><p>각각 오브젝트의 입력을 분명히게 받는 것이 아니라면, 
<code>req.body</code>, <code>req.params</code>, <code>req.query</code>으로의 직접 접속은 명확성을 띄어야 합니다. </p></section><section><h3 id="req.route">req.route</h3><p>루트 원본 경로 문자열, 생성된 regexp 등의 여러 속성을 포함하는 현재 매칭 된 <code>Route</code>입니다.
</p><pre class="js"><code>app.get('/user/:id?', function(req, res){
  console.log(req.route);
});
</code></pre><p>이전 예제는 다음과 같이 출력합니다.
</p><pre class="js"><code>{ path: '/user/:id?',
  keys: [ { name: 'id', optional: true } ],
  regexp: /^\/user(?:\/([^\/]+?))?\/?$/i,
  params: [ id: '12' ] }</code></pre></section><section><h3 id="req.cookies">req.cookies</h3><p><code>cookieParser()</code> 미들웨어가 사용 될 때,
이 오브젝트의 기본 값은 <code>{}</code>입니다. 그렇지 않을 경우는 user-agent에서 보낸 쿠키를 포함합니다.
</p><pre class="js"><code>// Cookie: name=tj
req.cookies.name
// => "tj"
</code></pre><p>더 많은 정보나 기타 사항은 <a href="https://github.com/expressjs/cookie-parser">cookie-parser</a>을 참고하세요.</p></section><section><h3 id="req.signedCookies">req.signedCookies</h3><p><code>cookieParser()</code> 미들웨어가 사용 될 때,
이 오브젝트의 기본 값은 <code>{}</code>입니다. 그렇지 않을 경우는 user-agent에서 보낸 signed 쿠키를 포함하고,
unsigned 쿠키는 사용 가능한 상태로 만들어줍니다.

Signed 쿠키는 개발자의 목적을 보여주기 위해 다른 오브젝트에 포함되며, 
그렇지 않을 경우, 악의적인 공격은 스푸핑 하기 쉬운 `req.cookie` 값에 위치됩니다.
쿠키에 sign 하는 것은 "숨기거나" 암호화 시키는 것을 의미하는 것이 아닌, 
단지 함부로 변경 하는 것을 방지하기 위함이라는 것을 알아두세요. 
</p><pre class="js"><code>// Cookie: user=tobi.CP7AWaXDfAKIRfH49dQzKJx7sKzzSoPq7/AcBBRVwlI3
req.signedCookies.user
// => "tobi"
</code></pre><p>더 많은 정보나 기타 사항은 <a href="https://github.com/expressjs/cookie-parser">cookie-parser</a>을 참고하세요.</p></section><section><h3 id="req.get">req.get(field)</h3><p> 
대소문자를 구분하지 않는 response 헤더 <code>field</code>를 불러옵니다.
<em>Referrer</em>과 <em>Referer</em> 필드는 교체 사용이 가능합니다.</p><pre class="js"><code>req.get('Content-Type');
// => "text/plain"

req.get('content-type');
// => "text/plain"

req.get('Something');
// => undefined
</code></pre><p><code>req.header(field)</code>라고도 쓰입니다.</p></section><section><h3 id="req.accepts">req.accepts(types)</h3><p>주어진 <code>types</code>가 받아 들일 수 있는지 검사하고, true일 경우 가장 좋은(best) 매치를 반환합니다.
그렇지 않을 경우 <code>undefined</code>를 반환하고, 이 경우에는 406 "Not Acceptable"라고 응답해야 합니다.
</p><p>반환되는 값이 있을 경우 리스트나 배열이 <em>가장 좋은(best)</em> 매치를 받을 때, 
<code>type</code> 값은 "application/json"이나 같은 하나의 mime 타입 문자열,
such as "json" 같은 확장자 이름, 콤마(,)로 범위가 지정된 리스트나 배열 일 수 있습니다.
</p><pre class="js"><code>// Accept: text/html
req.accepts('html');
// => "html"

// Accept: text/*, application/json
req.accepts('html');
// => "html"
req.accepts('text/html');
// => "text/html"
req.accepts('json, text');
// => "json"
req.accepts('application/json');
// => "application/json"

// Accept: text/*, application/json
req.accepts('image/png');
req.accepts('png');
// => undefined

// Accept: text/*;q=.5, application/json
req.accepts(['html', 'json']);
req.accepts('html, json');
// => "json"
</code></pre><p>더 많은 정보나 기타 사항은  <a href="https://github.com/expressjs/accepts">accepts</a>를 참고하세요.</p></section><section><h3 id="req.acceptsCharset">req.acceptsCharset(charset)</h3><p><code>charset</code>을 받아 들일 수 있는지 검사합니다.
</p><p>더 많은 정보나 기타 사항은 <a href="https://github.com/expressjs/accepts">accepts</a>를 참고하세요.</p></section><section><h3 id="req.acceptsLanguage">req.acceptsLanguage(lang)</h3><p><code>lang</code>를 받아 들일 수 있는지 검사합니다.
</p><p>더 많은 정보나 기타 사항은 <a href="https://github.com/expressjs/accepts">accepts</a>를 참고하세요.</p></section><section><h3 id="req.is">req.is(type)</h3><p>들어오는 요청이 "Content-Type" 헤더 필드를 포함하고 있는지 검사하고, 주어진 mime <code>type</code>을 매칭시킵니다.
</p><pre class="js"><code>// With Content-Type: text/html; charset=utf-8
req.is('html');
req.is('text/html');
req.is('text/*');
// => true

// When Content-Type is application/json
req.is('json');
req.is('application/json');
req.is('application/*');
// => true

req.is('html');
// => false
</code></pre><p>더 많은 정보나 기타 사항은 <a href="https://github.com/expressjs/type-is">type-is</a>를 참고하세요.</p></section><section><h3 id="req.ip">req.ip</h3><p>remote 주소를 반환하거나, "trust pxoty"가 활성화 되어 있을 떄 upstream 주소를 반환합니다.

</p><pre class="js"><code>req.ip
// => "127.0.0.1"</code></pre></section><section><h3 id="req.ips">req.ips</h3><p>"trust proxy"가 `true`일 때, "X-Forwarded-For" ip 주소 리스트를 파싱하고,
배열을 반환합니다.
그렇지 않은 경우에는 빈 배열이 반환됩니다.

예를 들어, 값이 "client, proxy1, proxy2"라면,
<code>["client", "proxy1", "proxy2"]</code>라는 배열이 반환되며, "proxy2"가 가장 멀리 있는 down-stream입니다.
</p></section><section><h3 id="req.path">req.path</h3><p>URL 경로 이름 요청을 반환합니다.
</p><pre class="js"><code>// example.com/users?sort=desc
req.path
// => "/users"</code></pre></section><section><h3 id="req.host">req.host</h3><p>"Host"의 헤더 필드(void of portno)로 부터 호스트 이름을 반환합니다.
</p><pre class="js"><code>// Host: "example.com:3000"
req.host
// => "example.com"</code></pre></section><section><h3 id="req.fresh">req.fresh</h3><p>요청이 최신(fresh)인지 검사합니다. 최근 변경 된 것이나, ETag가 아직도 매칭되는지 등을 통틀어 리소스가 '최신(fresh)이다'라고 표현합니다.
</p><pre class="js"><code>req.fresh
// => true
</code></pre><p>더 많은 정보나 기타 사항은 <a href="https://github.com/visionmedia/node-fresh">fresh</a>를 참고하세요.</p></section><section><h3 id="req.stale">req.stale</h3><p>요청이 오래 되었는지(stale) 검사합니다. 최근 변경 된 것이나, ETag가 매칭 되지 않는 것 등을 통틀어 리소스가 '오래 되었다(stale)'라고 표현합니다.

</p><pre class="js"><code>req.stale
// => true</code></pre></section><section><h3 id="req.xhr">req.xhr</h3><p>요청이 "X-Requested-With" 헤더 필드가 "XMLHttpRequest" (jQuery 등)로 설정되어 나왔는지 검사합니다. 
</p><pre class="js"><code>req.xhr
// => true</code></pre></section><section><h3 id="req.protocol">req.protocol</h3><p>TLS로 요청 될 때, "http"나 "https" 프로토콜 문자열을 반환합니다.
"trust proxy" 속성이 활성화 되어 있을 때, "X-Forwarded-Proto" 헤더 필드도 신뢰합니다.
http를 공급하는 역 프록시(reverse proxy) 뒤에서 수행하면, 이 속성은 활성화 됩니다.
</p><pre class="js"><code>req.protocol
// => "http"</code></pre></section><section><h3 id="req.secure">req.secure</h3><p>TLS 연결이 설정 되어 있는 지 확인합니다. 이는 아래를 위한 간략한 방법입니다.
</p><pre class="js"><code>'https' == req.protocol;</code></pre></section><section><h3 id="req.subdomains">req.subdomains</h3><p>서브 도메인을 배열 형태로 반환합니다..
</p><pre class="js"><code>// Host: "tobi.ferrets.example.com"
req.subdomains
// => ["ferrets", "tobi"]</code></pre></section><section><h3 id="req.originalUrl">req.originalUrl</h3><p>이 속성은 <code>req.url</code>와 매우 흡사하지만, 원본 요청 url을 포함하고
내부적인 라우팅 목적을 위해 <code>req.url</code>을 자유롭게 rewrite 할 수 있도록 해줍니다. 
예를 들어, <a href="#app.use">app.use()</a>의 "mounting" 기능은 
마운트 포인트를 strip 할 수 있도록 <code>req.url</code>을 rewrite 합니다.
</p><pre class="js"><code>// GET /search?q=something
req.originalUrl
// => "/search?q=something"</code></pre></section><h2>Response</h2><a name="response"></a><section><h3 id="res.status">res.status(code)</h3><p>체인화 할 수 있는 (Chainable) 노드의 <code>res.statusCode=</code>의 alias입니다. 
</p><pre class="js"><code>res.status(404).sendfile('path/to/404.png');</code></pre></section><section><h3 id="res.set">res.set(field, [value])</h3><p> 
Set 헤더 <code>field</code>를 <code>value</code>로 설정합니다.
오브젝트를 여러 필드를 한꺼번에 설정하기 위해 오브젝트를 넘깁니다. </p><pre class="js"><code>res.set('Content-Type', 'text/plain');

res.set({
  'Content-Type': 'text/plain',
  'Content-Length': '123',
  'ETag': '12345'
})
</code></pre><p><code>res.header(field, [value])</code>라고도 알려져 있습니다.</p></section><section><h3 id="res.get">res.get(field)</h3><p> 
대소문자를 구분하지 않는 response 헤더 <code>field</code>를 불러옵니다.</p><pre class="js"><code>res.get('Content-Type');
// => "text/plain"</code></pre></section><section><h3 id="res.cookie">res.cookie(name, value, [options])</h3><p>쿠키의 <code>name</code>을 <code>value</code> 설정하며,
이는 문자열이나 JSON으로 변환 된 오브젝트 입니다.
The <code>path</code> 옵션의 기본 값은 "/"입니다.
</p><pre class="js"><code>res.cookie('name', 'tobi', { domain: '.example.com', path: '/admin', secure: true });
res.cookie('rememberme', '1', { expires: new Date(Date.now() + 900000), httpOnly: true });
</code></pre><p><code>maxAge</code> 옵션은 "expires" 설정을 위한 것이며, 현재 시간을 밀리초로 설정 해 줍니다., 
아래 예제는 이전 예제와 같습니다.

</p><pre class="js"><code>res.cookie('rememberme', '1', { maxAge: 900000, httpOnly: true })
</code></pre><p>오브젝트는 JSON처럼 시리즈화(serialized) 되어 넘겨지며, 이것은 <code>bodyParser()</code> 미들웨어에 의해
자동적으로 파싱됩니다. 

</p><pre class="js"><code>res.cookie('cart', { items: [1,2,3] });
res.cookie('cart', { items: [1,2,3] }, { maxAge: 900000 });
</code></pre><p>Signed cookies are also supported through this method. 
Signed 쿠키는 또한 이 메소드를 통해 지원됩니다.
단순히 <code>signed</code> 옵션을 넘기세요.
주어진 <code>res.cookie()</code>가 값을 sign 하기 위해
<code>cookieParser(secret)</code>로 넘겨진 비밀(secret)을 사용 할 것입니다.

</p><pre class="js"><code>res.cookie('name', 'tobi', { signed: true });
</code></pre><p>이후, <a href="#req.signedCookies">req.signedCookie</a> 오브젝트를 통해 이 값에 접근 할 수 있습니다.</p></section><section><h3 id="res.clearCookie">res.clearCookie(name, [options])</h3><p>쿠키 <code>name</code>를 클리어 해 줍니다. 
경로 옵션의 기본 값은 "/"입니다.
</p><pre class="js"><code>res.cookie('name', 'tobi', { path: '/admin' });
res.clearCookie('name', { path: '/admin' });</code></pre></section><section><h3 id="res.redirect">res.redirect([status], url)</h3><p>선택적 <code>status</code>코드와 주어진 <code>url</code>로 우회합니다.
기본 값은 302 "Found" 입니다.
</p><pre class="js"><code>res.redirect('/foo/bar');
res.redirect('http://example.com');
res.redirect(301, 'http://example.com');
res.redirect('../login');
</code></pre><p>Express는 여러 우회 방법을 지원합니다. 
완전히 qualified 된 URI가 다른 사이트로 우회 하려면,
</p><pre class="js"><code>res.redirect('http://google.com');
</code></pre><p>두 번째 방법은 경로이름과 관계된 우회 방법입니다.
예를 들면 <code>http://example.com/admin/post/new</code>에 있고
그 우회로가 <code>/admin</code>라면, <code>http://example.com/admin</code>로 접근 시켜 줍니다.
</p><pre class="js"><code>res.redirect('/admin');
</code></pre><p>그 다음 방법은 애플리케이션의 <code>mount</code> 포인트를 사용한 방법입니다.
예를 들어, 만약 <code>/blog</code>에 마운트 된 블로그 애플리케이션이 있다면, 이상적으로
이것은 어디에서 마운트 되었는지의 정보를 가지고 있지 않으며,
이는 <code>/admin/post/new</code>의 우회로가 단순히 <code>http://example.com/admin/post/new</code>라는 우회를
넘겨주게 되며, 이는 <code>http://example.com/blog/admin/post/new</code>로 접근 시켜 줍니다.

</p><pre class="js"><code>res.redirect('admin/post/new');
</code></pre><p>Pathname relative redirects are also possible. 
경로 이름으로 우회하는 방법 또한 가능합니다.
만약 <code>http://example.com/admin/post/new</code>에 있다면 그 우회로는 
<code>http//example.com/admin/post</code>로 접근 시켜 줍니다.
</p><pre class="js"><code>res.redirect('..');
</code></pre><p>. 
마지막 특별한 방법은 <code>back</code> 우회법인데, Referer (혹은 Referrer)로 다시 우회 시켜주는 방법이며,
값이 지정 되어 있지 않을 때, 기본 값은 <code>/</code>입니다.</p><pre class="js"><code>res.redirect('back');

</code></pre></section><section><h3 id="res.location">res.location</h3><p>위치(location) 헤더를 설정합니다.
</p><pre class="js"><code>res.location('/foo/bar');
res.location('foo/bar');
res.location('http://example.com');
res.location('../login');
res.location('back');
</code></pre><p><code>res.redirect()</code>와 같이, 같은 종류의 <code>urls</code>를 사용 할 수 있습니다.
</p><p>For example, 
예를 들어, 애플리케이션이 <code>/blog</code>에 마운트 되어 있으면
아래는 <code>location</code> 헤더를 <code>/blog/admin</code>로 설정 해 줍니다.
</p><pre class="js"><code>res.location('admin')</code></pre></section><section><h3 id="res.send">res.send([body|status], [body])</h3><p>Response를 보냅니다.
</p><pre class="js"><code>res.send(new Buffer('whoop'));
res.send({ some: 'json' });
res.send('<p>some html</p>');
res.send(404, 'Sorry, we cannot find that!');
res.send(500, { error: 'something blew up' });
res.send(200);
</code></pre><p>이 메소드는 
미리 정의 되고, 오토메틱 <em>HEAD</em>과 HTTP cache freshness 지원을 제공하고 있지 않는 한
자동적으로 Content-Length를 할당하는 것과 같은 단순 non-streaming response의
유용한 task를 수행하는 데에 사용됩니다.
</p><p>When a <code>Buffer</code> is given
<code>Buffer</code>가 주어 질 때, Content-Type은
아래와 같이 미리 정의 되지 않는 한,
"application/octet-stream"로 설정됩니다. 

</p><pre class="js"><code>res.set('Content-Type', 'text/html');
res.send(new Buffer('<p>some html</p>'));
</code></pre><p><code>String</code>가 주어 질 때, Content-Type은
기본적으로 "text/html"로 설정됩니다.
</p><pre class="js"><code>res.send('<p>some html</p>');
</code></pre><p><code>Array</code>나 <code>Object</code>가 주어 질 때,
Express는 JSON representation에 응답합니다.
</p><pre class="js"><code>res.send({ user: 'tobi' })
res.send([1,2,3])
</code></pre><p>마지막으로 <code>Number</code>가 미리 언급 된 body없이 주어 질 때,
response body 문자열이 할당 됩니다.
예를 들어, 200은 "OK"라고 응답(respond)하며,
404는 "Not Found" 등으로 나타납니다.

</p><pre class="js"><code>res.send(200)
res.send(404)
res.send(500)</code></pre></section><section><h3 id="res.json">res.json([status|body], [body])</h3><p>Send a JSON response. This method is identical
to <code>res.send()</code> when an object or
array is passed, however it may be used for
explicit JSON conversion of non-objects (null, undefined, etc),
though these are technically not valid JSON.
</p><pre class="js"><code>res.json(null)
res.json({ user: 'tobi' })
res.json(500, { error: 'message' })</code></pre></section><section><h3 id="res.jsonp">res.jsonp([status|body], [body])</h3><p>Send a JSON response with JSONP support. This method is identical
to <code>res.json()</code> however opts-in to JSONP callback
support.
</p><pre class="js"><code>res.jsonp(null)
// => null

res.jsonp({ user: 'tobi' })
// => { "user": "tobi" }

res.jsonp(500, { error: 'message' })
// => { "error": "message" }
</code></pre><p>By default the JSONP callback name is simply <code>callback</code>,
however you may alter this with the <a href="#app-settings">jsonp callback name</a>
setting. The following are some examples of JSONP responses using the same
code:
</p><pre class="js"><code>// ?callback=foo
res.jsonp({ user: 'tobi' })
// => foo({ "user": "tobi" })

app.set('jsonp callback name', 'cb');

// ?cb=foo
res.jsonp(500, { error: 'message' })
// => foo({ "error": "message" })</code></pre></section><section><h3 id="res.type">res.type(type)</h3><p>Sets the Content-Type to the mime lookup of <code>type</code>,
or when "/" is present the Content-Type is simply set to this
literal value.
</p><pre class="js"><code>res.type('.html');
res.type('html');
res.type('json');
res.type('application/json');
res.type('png');</code></pre></section><section><h3 id="res.format">res.format(object)</h3><p>Performs content-negotiation on the request Accept header
field when present. This method uses <code>req.accepted</code>, an array of
acceptable types ordered by their quality values, otherwise the
first callback is invoked. When no match is performed the server
responds with 406 "Not Acceptable", or invokes the <code>default</code>
callback.
</p><p>The Content-Type is set for you when a callback is selected,
however you may alter this within the callback using <code>res.set()</code>
or <code>res.type()</code> etcetera.
</p><p>The following example would respond with <code>{ "message": "hey" }</code>
when the Accept header field is set to "application/json" or "*/json",
however if "*/*" is given then "hey" will be the response.
</p><pre class="js"><code>res.format({
  'text/plain': function(){
    res.send('hey');
  },
  
  'text/html': function(){
    res.send('<p>hey</p>');
  },
  
  'application/json': function(){
    res.send({ message: 'hey' });
  }
});
</code></pre><p>In addition to canonicalized MIME types you may also
use extnames mapped to these types, providing a slightly
less verbose implementation:
</p><pre class="js"><code>res.format({
  text: function(){
    res.send('hey');
  },
  
  html: function(){
    res.send('<p>hey</p>');
  },
  
  json: function(){
    res.send({ message: 'hey' });
  }
});</code></pre></section><section><h3 id="res.attachment">res.attachment([filename])</h3><p>Sets the Content-Disposition header field to "attachment". If
a <code>filename</code> is given then the Content-Type will be
automatically set based on the extname via <code>res.type()</code>,
and the Content-Disposition's "filename=" parameter will be set.
</p><pre class="js"><code>res.attachment();
// Content-Disposition: attachment

res.attachment('path/to/logo.png');
// Content-Disposition: attachment; filename="logo.png"
// Content-Type: image/png</code></pre></section><section><h3 id="res.sendfile">res.sendfile(path, [options], [fn])</h3><p>Transfer the file at the given <code>path</code>.</p><p>Automatically defaults the Content-Type response header field based
on the filename's extension. The callback <code>fn(err)</code> is
invoked when the transfer is complete or when an error occurs.
</p><p>Options:</p><ul><li><code>maxAge</code> in milliseconds defaulting to 0</li><li><code>root</code> root directory for relative filenames</li></ul><p>This method provides fine-grained support for file serving
as illustrated in the following example:
</p><pre class="js"><code>app.get('/user/:uid/photos/:file', function(req, res){
  var uid = req.params.uid
    , file = req.params.file;
    
  req.user.mayViewFilesFrom(uid, function(yes){
    if (yes) {
      res.sendfile('/uploads/' + uid + '/' + file);
    } else {
      res.send(403, 'Sorry! you cant see that.');
    }
  });
});
</code></pre><p>Please refer to <a href="https://github.com/visionmedia/send">send</a> for additional documentation or any issues and concerns.</p></section><section><h3 id="res.download">res.download(path, [filename], [fn])</h3><p>Transfer the file at <code>path</code> as an "attachment",
typically browsers will prompt the user for download. The
Content-Disposition "filename=" parameter, aka the one
that will appear in the brower dialog is set to <code>path</code>
by default, however you may provide an override <code>filename</code>.
</p><p>When an error has ocurred or transfer is complete the optional 
callback <code>fn</code> is invoked. This method uses <a href="#res.sendfile">res.sendfile()</a>
to transfer the file.
</p><pre class="js"><code>res.download('/report-12345.pdf');

res.download('/report-12345.pdf', 'report.pdf');

res.download('/report-12345.pdf', 'report.pdf', function(err){
  if (err) {
    // handle error, keep in mind the response may be partially-sent
    // so check res.headersSent
  } else {
    // decrement a download credit etc
  }
});</code></pre></section><section><h3 id="res.links">res.links(links)</h3><p>Join the given <code>links</code> to populate the "Link"
response header field.
</p><pre class="js"><code>res.links({
  next: 'http://api.example.com/users?page=2',
  last: 'http://api.example.com/users?page=5'
});
</code></pre><p>yields:</p><pre><code>Link: &lt;http://api.example.com/users?page=2&gt;; rel="next", 
      &lt;http://api.example.com/users?page=5&gt;; rel="last"</code></pre></section><section><h3 id="res.locals">res.locals</h3><p>Response local variables are scoped to the request, thus only
available to the view(s) rendered during that request / response
cycle, if any. Otherwise this API is identical to <a href="#app.locals">app.locals</a>.
</p><p>This object is useful for exposing request-level information such as the
request pathname, authenticated user, user settings etcetera.
</p><pre class="js"><code>app.use(function(req, res, next){
  res.locals.user = req.user;
  res.locals.authenticated = ! req.user.anonymous;
  next();
});</code></pre></section><section><h3 id="res.render">res.render(view, [locals], callback)</h3><p>Render a <code>view</code> with a callback responding with
the rendered string. When an error occurs <code>next(err)</code>
is invoked internally. When a callback is provided both the possible error
and rendered string are passed, and no automated response is performed.
</p><pre class="js"><code>res.render('index', function(err, html){
  // ...
});

res.render('user', { name: 'Tobi' }, function(err, html){
  // ...
});</code></pre></section><h2>Router</h2><a name="router"></a><section><h3 id="router">Router()</h3><p>A router is an isolated instance of middleware and routes. Routers can be thought of as "mini" applications only capable of performing middleware and routing. Every express application has a builtin app router.
</p><p>Routers behave like middleware themselves and can be ".use()'d" by the app or in other routers.
</p><p>Create a new router by using "express.Router()"
</p><pre class="js"><code>var router = express.Router([options]);
</code></pre><p>Options is an optional object to alter the route matching behavior of the router.
</p><ul><li><code>caseSensitive </code>Enable case sensitivity, disabled by default, treating "/Foo" and "/foo" as the same</li><li><code>strict </code>Enable strict routing, by default "/foo" and "/foo/" are treated the same by the router</li></ul><p>The router can have middleware and http VERB routes added just like an application.
</p><pre class="js"><code>// invoked for any requests passed to this router
router.use(function(req, res, next) {
  // .. some logic here .. like any other middleware
  next();
});

// will handle any request that ends in /events
// depends on where the router is "use()'d"
router.get('/events', function(req, res, next) {
  // ..
});
</code></pre><p>You can then use a router for a particular root url in this way separating your routes into files or even mini apps.
</p><pre class="js"><code>// only requests to /calendar/* will be sent to our "router"
app.use('/calendar', router);
</code></pre></section><section><h3 id="router.use">router.use([path], function)</h3><p>Use the given middleware <code>function</code>, with optional mount <code>path</code>,
defaulting to "/".
</p><p>Middleware is like a plumbing pipe, requests start at the first middleware you define and work their way "down" the middleware stack processing for each path they match.
</p><pre class="js"><code>var express = require('express');
var app = express();
var router = express.Router();

// simple logger for this router's requests
// all requests to this router will first hit this middleware
router.use(function(req, res, next) {
  console.log('%s %s %s', req.method, req.url, req.path);
  next();
});

// this will only be invoked if the path ends in /bar
router.use('/bar', function(req, res, next) {
  // ... maybe some additional /bar logging ...
  next();
});

// always invoked
router.use(function(req, res, next) {
  res.send('Hello World');
});

app.use('/foo', router);

app.listen(3000);
</code></pre><p>The "mount" path is stripped and is <strong>not</strong> visible
to the middleware <code>function</code>. The main effect of this feature is that
mounted middleware may operate without code changes regardless of its "prefix"
pathname.
</p><p>The order of which middleware are "defined" using <code>router.use()</code> is
very important, they are invoked sequentially, thus this defines middleware
precedence. For example usually a logger is the very
first middleware you would use, logging every request:
</p><pre class="js"><code>var logger = require('morgan');

router.use(logger());
router.use(express.static(__dirname + '/public'));
router.use(function(req, res){
  res.send('Hello');
});
</code></pre><p>Now suppose you wanted to ignore logging requests for static files, but to
continue logging routes and middleware defined after <code>logger()</code>,
you would simply move <code>static()</code> above:
</p><pre class="js"><code>router.use(express.static(__dirname + '/public'));
router.use(logger());
router.use(function(req, res){
  res.send('Hello');
});
</code></pre><p>Another concrete example would be serving files from multiple directories,
giving precedence to "./public" over the others:
</p><pre class="js"><code>app.use(express.static(__dirname + '/public'));
app.use(express.static(__dirname + '/files'));
app.use(express.static(__dirname + '/uploads'));</code></pre></section><section><h3 id="router.param">router.param([name], callback)</h3><p>Map logic to route parameters. For example when <code>:user</code>
is present in a route path you may map user loading logic to automatically
provide <code>req.user</code> to the route, or perform validations
on the parameter input.
</p><p>The following snippet illustrates how the <code>callback</code>
is much like middleware, thus supporting async operations, however
providing the additional value of the parameter, here named as <code>id</code>.
An attempt to load the user is then performed, assigning <code>req.user</code>,
otherwise passing an error to <code>next(err)</code>.
</p><p>It is important to realize that any route that triggered a named parameter function to run will only be run if <code>next</code> was not called with an error in the named parameter handler.
</p><pre class="js"><code>router.param('user', function(req, res, next, id){
  User.find(id, function(err, user){
    if (err) {
      return next(err);
    }
    else if (!user) {
      return next(new Error('failed to load user'));
    }
    
    req.user = user;
    next();
  });
});

// this route uses the ":user" named parameter
// which will cause the 'user' param callback to be triggered
router.get('/users/:user', function(req, res, next) {
  // req.user WILL be defined here
  // if there was an error, normal error handling will be triggered
  // and this function will NOT execute
});
</code></pre><p>Alternatively you may pass only a <code>callback</code>, in which
case you have the opportunity to alter the <code>router.param()</code> API.
For example the <a href="http://github.com/visionmedia/express-params">express-params</a>
defines the following callback which allows you to restrict parameters to a given
regular expression.
</p><p>This example is a bit more advanced, checking if the second argument is a regular
expression, returning the callback which acts much like the "user" param example.
</p><pre class="js"><code>router.param(function(name, fn){
  if (fn instanceof RegExp) {
    return function(req, res, next, val){
      var captures;
      if (captures = fn.exec(String(val))) {
        req.params[name] = captures;
        next();
      } else {
        next('route');
      }
    }
  }
});
</code></pre><p>The method could now be used to effectively validate parameters, or also
parse them to provide capture groups:
</p><pre class="js"><code>router.param('id', /^\d+$/);

router.get('/user/:id', function(req, res){
  res.send('user ' + req.params.id);
});

router.param('range', /^(\w+)\.\.(\w+)?$/);

router.get('/range/:range', function(req, res){
  var range = req.params.range;
  res.send('from ' + range[1] + ' to ' + range[2]);
});
</code></pre><p>The <code>router.use()</code> method also supports named parameters so that your mount points for other routers can benefit from preloading using named parameters.</p></section><section><h3 id="router.route">router.route(path)</h3><p>Returns an instance of a single route which can then be used to handle HTTP verbs with optional middleware. Using <code>router.route()</code> is a recommended approach to avoiding duplicate route naming and thus typo errors.
</p><p>Building on the <code>router.param()</code> example from before, we see how <code>router.route()</code> allows us to easily specify the various HTTP verb handlers.
</p><pre class="js"><code>var router = express.Router();

router.param('user_id', function(req, res, next, id) {
  // sample user, would actually fetch from DB, etc...
  req.user = {
    id: id,
    name: 'TJ'
  };
  next();
});

router.route('/users/:user_id')
.all(function(req, res, next) {
  // runs for all HTTP verbs first
  // think of it as route specific middleware!
})
.get(function(req, res, next) {
  res.json(req.user);
})
.put(function(req, res, next) {
  // just an example of maybe updating the user
  req.user.name = req.params.name;
  // save user ... etc
  res.json(req.user);
})
.post(function(req, res, next) {
  next(new Error('not implemented'));
})
.delete(function(req, res, next) {
  next(new Error('not implemented'));
})
</code></pre><p>This apporach re-uses the single '/users/:user_id' path and add handlers for the various HTTP verbs.</p></section><section><h3 id="router.VERB">router.VERB(path, [callback...], callback)</h3><p>The <code>router.VERB()</code> methods provide the routing functionality
in Express, where <strong>VERB</strong> is one of the HTTP verbs, such
as <code>router.post()</code>. Multiple callbacks may be given, all are treated
equally, and behave just like middleware, with the one exception that
these callbacks may invoke <code>next('route')</code> to bypass the
remaining route callback(s). This mechanism can be used to perform pre-conditions
on a route then pass control to subsequent routes when there is no reason to proceed
with the route matched.
</p><p>The following snippet illustrates the most simple route definition possible. Express
translates the path strings to regular expressions, used internally to match incoming requests.
Query strings are <em>not</em> considered when peforming these matches, for example "GET /"
would match the following route, as would "GET /?name=tobi".
</p><pre class="js"><code>router.get('/', function(req, res){
  res.send('hello world');
});
</code></pre><p>Regular expressions may also be used, and can be useful
if you have very specific restraints, for example the following
would match "GET /commits/71dbb9c" as well as "GET /commits/71dbb9c..4c084f9".
</p><pre class="js"><code>router.get(/^\/commits\/(\w+)(?:\.\.(\w+))?$/, function(req, res){
  var from = req.params[0];
  var to = req.params[1] || 'HEAD';
  res.send('commit range ' + from + '..' + to);
});</code></pre></section><h2>Middleware</h2><a name="middleware"></a><p> 
4.x부터, Express는 Connect에 종속적이지 않습니다.
이전에 포함 된 모든 미들웨어는 이제는 분리된 repo입니다.
<a href="https://github.com/senchalabs/connect#middleware">the list of middleware</a>를 찹고해 주세요.
이제 포함된 미들웨어는 <code>express.static()</code>뿐 입니다.</p></div></section><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-38025412-4', 'auto');
ga('send', 'pageview');
</script><a id="top" href="#"><img src="/images/arrow.png"></a></body></html>