section
  h3(id='router.use') router.use([path], function)
  
  p.
    주어진 <code>function</code> 미들웨어와 optional 마운트인 <code>path</code>를 사용합니다. 기본 값은 "/"입니다.

  p.
    request들은 당신이 정의한 첫번째 미들웨어에서 시작하며, 그들이 매칭하는 각 경로를 처리하며 미들웨어 스택 아래로 아동합니다. 

  +js.
    var express = require('express');
    var app = express();
    var router = express.Router();

    // simple logger for this router's requests
    // all requests to this router will first hit this middleware
    router.use(function(req, res, next) {
      console.log('%s %s %s', req.method, req.url, req.path);
      next();
    });

    // this will only be invoked if the path ends in /bar
    router.use('/bar', function(req, res, next) {
      // ... maybe some additional /bar logging ...
      next();
    });

    // always invoked
    router.use(function(req, res, next) {
      res.send('Hello World');
    });

    app.use('/foo', router);

    app.listen(3000);

  p.
    "mount"경로는 stripped되며, middleware <code>function</code>에 보이지 <strong>않습니다.</strong>
    이 특징의 가장 큰 효과는 마운트 된 미들웨어는 "prefix" 경로 이름에 상관 없이 코드의 변환 없이도 실행 할 수 있다는 것입니다. 

  p.
    <code>router.use()</code>를 사용하는 "정의 된" 미들웨어의 순서는 매우 중요하며, 그 미들웨어들은 순서대로 호출됩니다.
    그러므로 이는 미들웨어의 우선순위를 정의합니다.
    예를 들어, logger는 사용 하는 미들웨어의 가장 첫번째이며, 매 요청을 로깅합니다.

  +js.
    var logger = require('morgan');

    router.use(logger());
    router.use(express.static(__dirname + '/public'));
    router.use(function(req, res){
      res.send('Hello');
    });

  p.
    만일 static 파일을 위한 로깅 요청을 무시하고, 계속해서 라우트를 로깅하고 싶다면,
    미들웨어는 <code>logger()</code> 이후에 정의되며, 단순히 위의 <code>static()</code>로 이동합니다.

  +js.
    router.use(express.static(__dirname + '/public'));
    router.use(logger());
    router.use(function(req, res){
      res.send('Hello');
    });

  p.
    다른 예제는, 여러 디렉토리로 부터 파일을 serving하는 것입니다. 이는 다른 것으로 보다도 "./public"에게 우선순위를 줍니다.

  +js.
    app.use(express.static(__dirname + '/public'));
    app.use(express.static(__dirname + '/files'));
    app.use(express.static(__dirname + '/uploads'));
