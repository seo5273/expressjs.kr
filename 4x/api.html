<!DOCTYPE html><html><head><title>Express - API 레퍼런스</title><link rel="stylesheet" href="/style.css"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Open+Sans:300,400,600,700&amp;amp;subset=latin,latin-ext"><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><script src="http://ajax.googleapis.com/ajax/libs/jquery/1.11.0/jquery.min.js"></script><script src="/app.js"></script><script src="/retina.js"></script></head><body class="inner"><div class="bar"></div><section id="content"><header><section id="logo"><a href="/" class="express">express kr</a><span class="description"><a href="http://nodejs.org">node</a>를 위한<br>웹 애플리케이션<br>프레임워크</span></section><nav class="clearfix"><a href="/">홈</a><a href="/4x/api.html" class="active">API 레퍼런스</a><a href="/guide.html">가이드</a><a href="/applications.html">애플리케이션</a><a href="/community.html">커뮤니티</a><a href="/faq.html">FAQ</a><a href="http://expressjs.com/3x/api.html">3.x 문서</a></nav></header><ul id="menu"><li id="app-api"><a href="#express">Application</a><ul id="app-menu"><li><a href="#express">express()</a></li><li><a href="#app-settings">application settings</a></li><li><a href="#app.set">app.set()</a></li><li><a href="#app.get">app.get()</a></li><li><a href="#app.enable">app.enable()</a></li><li><a href="#app.disable">app.disable()</a></li><li><a href="#app.enabled">app.enabled()</a></li><li><a href="#app.disabled">app.disabled()</a></li><li><a href="#app.use">app.use()</a></li><li><a href="#app.engine">app.engine()</a></li><li><a href="#app.param">app.param()</a></li><li><a href="#app.VERB">application routing</a></li><li><a href="#app.all">app.all()</a></li><li><a href="#app.route">app.route()</a></li><li><a href="#app.locals">app.locals</a></li><li><a href="#app.render">app.render()</a></li><li><a href="#app.listen">app.listen()</a></li></ul></li><li id="req-api"><a href="#req.params">Request</a><ul id="req-menu"><li><a href="#req.params">req.params</a></li><li><a href="#req.query">req.query</a></li><li><a href="#req.param">req.param()</a></li><li><a href="#req.route">req.route</a></li><li><a href="#req.cookies">req.cookies</a></li><li><a href="#req.signedCookies">req.signedCookies</a></li><li><a href="#req.get">req.get()</a></li><li><a href="#req.accepts">req.accepts()</a></li><li><a href="#req.acceptsCharsets">req.acceptsCharsets()</a></li><li><a href="#req.acceptsLanguages">req.acceptsLanguages()</a></li><li><a href="#req.acceptsEncodings">req.acceptsEncodings()</a></li><li><a href="#req.is">req.is()</a></li><li><a href="#req.ip">req.ip</a></li><li><a href="#req.ips">req.ips</a></li><li><a href="#req.path">req.path</a></li><li><a href="#req.hostname">req.hostname</a></li><li><a href="#req.fresh">req.fresh</a></li><li><a href="#req.stale">req.stale</a></li><li><a href="#req.xhr">req.xhr</a></li><li><a href="#req.protocol">req.protocol</a></li><li><a href="#req.secure">req.secure</a></li><li><a href="#req.subdomains">req.subdomains</a></li><li><a href="#req.originalUrl">req.originalUrl</a></li></ul></li><li id="res-api"><a href="#res.status">Response</a><ul id="res-menu"><li><a href="#res.status">res.status()</a></li><li><a href="#res.set">res.set()</a></li><li><a href="#res.get">res.get()</a></li><li><a href="#res.cookie">res.cookie()</a></li><li><a href="#res.clearCookie">res.clearCookie()</a></li><li><a href="#res.redirect">res.redirect()</a></li><li><a href="#res.location">res.location()</a></li><li><a href="#res.send">res.send()</a></li><li><a href="#res.json">res.json()</a></li><li><a href="#res.jsonp">res.jsonp()</a></li><li><a href="#res.type">res.type()</a></li><li><a href="#res.format">res.format()</a></li><li><a href="#res.attachment">res.attachment()</a></li><li><a href="#res.sendfile">res.sendfile()</a></li><li><a href="#res.download">res.download()</a></li><li><a href="#res.links">res.links()</a></li><li><a href="#res.locals">res.locals</a></li><li><a href="#res.render">res.render()</a></li></ul></li><li id="router-api"><a href="#router">Router</a><ul id="router-menu"><li><a href="#router">Router()</a></li><li><a href="#router.use">router.use()</a></li><li><a href="#router.param">router.param()</a></li><li><a href="#router.route">router.route()</a></li><li><a href="#router.VERB">router.VERB()</a></li></ul></li><li id="middleware-api"><a href="#middleware">Middleware</a><ul id="middleware-menu"><li><a href="#basicAuth">basicAuth()</a></li><li><a href="#bodyParser">bodyParser()</a></li><li><a href="#compress">compress()</a></li><li><a href="#cookieParser">cookieParser()</a></li><li><a href="#cookieSession">cookieSession()</a></li><li><a href="#csrf">csrf()</a></li><li><a href="#directory">directory()</a></li></ul></li></ul><div id="right"><section><h3 id="express">express()</h3><p>express 애플리케이션을 생성합니다.
</p><pre class="js"><code>var express = require('express');
var app = express();

app.get('/', function(req, res){
  res.send('hello world');
});

app.listen(3000);</code></pre></section><h2>Application</h2><a name="application"></a><section><h3 id="app-settings">설정</h3><p>아래 설정들은 Express가 어떻게 행동할지 정합니다.
</p><ul><li><code>env </code>환경 모드를 설정합니다. 기본값은 <code>process.env.NODE_ENV</code> (NODE_ENV 환경 변수) 혹은 "development"입니다.</li><li><code>trust proxy </code>역 프록시(reverse proxy) 지원을 활성화 시킬지 결정합니다. 기본값은 비활성화입니다.</li><li><code>jsonp callback name </code>jsonp에 사용되는 콜백 이름을 변경합니다. 기본값은 "callback"입니다. (<code>?callback=</code>)</li><li><code>json replacer </code>JSON 대체 콜백입니다. 기본 값은 null 입니다.</li><li><code>case sensitive routing </code>대소문자 구분을 활성화시킵니다. 기본값은 비활성화로, "/Foo"와 "/foo"를 같은 것으로 취급합니다.</li><li><code>strict routing </code>엄격한 라우팅(strict routing)을 활성화 시킵니다. 기본적으로 라우터는 "/foo" 와 "/foo/"를 같은 것으로 취급합니다.</li><li><code>view cache </code>뷰 템플릿 캐싱을 활성화 시킵니다. 기본적으로 production 모드에서는 활성화 되어있습니다.</li><li><code>view engine </code>기본 뷰 엔진을 변경합니다.</li><li><code>views </code>뷰들이 저장되어 있는 디렉토리 경로입니다. 기본값은 "process.cwd() + '/views'"입니다.</li><li><code>x-powered-by </code><code>X-Powered-By: Express</code>의 HTTP 헤더를 활성화 시킵니다. 기본값은 활성화입니다.</li></ul></section><section><h3 id="app.set">app.set(name, value)</h3><p><code>name</code>의 값을 <code>value</code>로 설정합니다.
</p><pre class="js"><code>app.set('title', 'My Site');
app.get('title');
// => "My Site"</code></pre></section><section><h3 id="app.get">app.get(name)</h3><p>설정한 <code>name</code>의 값을 불러옵니다.
</p><pre class="js"><code>app.get('title');
// => undefined

app.set('title', 'My Site');
app.get('title');
// => "My Site"</code></pre></section><section><h3 id="app.enable">app.enable(name)</h3><p><code>name</code>의 값을 <code>true</code>로 설정합니다.
</p><pre class="js"><code>app.enable('trust proxy');
app.get('trust proxy');
// => true</code></pre></section><section><h3 id="app.disable">app.disable(name)</h3><p><code>name</code>의 값을 <code>false</code>로 설정합니다.
</p><pre class="js"><code>app.disable('trust proxy');
app.get('trust proxy');
// => false</code></pre></section><section><h3 id="app.enabled">app.enabled(name)</h3><p><code>name</code>설정이 활성화되어 있는지 확인합니다.
</p><pre class="js"><code>app.enabled('trust proxy');
// => false

app.enable('trust proxy');
app.enabled('trust proxy');
// => true</code></pre></section><section><h3 id="app.disabled">app.disabled(name)</h3><p><code>name</code>설정이 비활성화되어 있는지 확인합니다.
</p><pre class="js"><code>app.disabled('trust proxy');
// => true

app.enable('trust proxy');
app.disabled('trust proxy');
// => false</code></pre></section><section><h3 id="app.use">app.use([path], function)</h3><p>앱에 미들웨어를 로드합니다. 미들웨어는 <code>function</code>입니다. (<code>경로</code>를 지정할 수 있습니다. 경로의 기본값은 "/"입니다.
</p><pre class="js"><code>var express = require('express');
var app = express();

// simple logger
app.use(function(req, res, next){
  console.log('%s %s', req.method, req.url);
  next();
});

// respond
app.use(function(req, res, next){
  res.send('Hello World');
});

app.listen(3000);
</code></pre><p>경로는 미들웨어와 아무런 관계가 없습니다. 즉 경로를 바꾸어도 미들웨어의 코드의 수정은 필요치 않습니다.
</p><p>아래의 예제는 <code>express.static()</code> 미들웨어를 사용하여 애플리케이션이 ./public안의 파일들을 제공하는 기능을 작성한 것입니다.
</p><pre class="js"><code>// GET /javascripts/jquery.js
// GET /style.css
// GET /favicon.ico
app.use(express.static(__dirname + '/public'));
</code></pre><p>예를 들어, 모든 정적 파일 접근시 "/static"을 접두어로 사용하고 싶다면 아래와 같이 설정할 수 있습니다.
이는 <code>req.url</code>가 "/static"을 포함하고 있지 않으면 <strong>호출 되지 않습니다.</strong>
</p><pre class="js"><code>// GET /static/javascripts/jquery.js
// GET /static/style.css
// GET /static/favicon.ico
app.use('/static', express.static(__dirname + '/public'));
</code></pre><p><code>app.use()</code>을 사용하여 정의 된 미들웨어의 순서는, 미들웨어의 우선순위를 정하기 때문에 매우 중요하며, 미들웨어는 이 순서대로 호출됩니다.
예를 들어, 대체로 로깅 미들웨어는 다른 미들웨어 보다 가장 상단에 설정됩니니다.
</p><pre class="js"><code>var logger = require('morgan');

app.use(logger());
app.use(express.static(__dirname + '/public'));
app.use(function(req, res){
  res.send('Hello');
});
</code></pre><p>만약 정적 파일을 제공할 때는 로깅 요청을 무시하고, <code>logger()</code> 후에 미들웨어 정의를 계속 하고 싶다면,
<code>static()</code>을 logger 위로 옮기세요.
</p><pre class="js"><code>app.use(express.static(__dirname + '/public'));
app.use(logger());
app.use(function(req, res){
  res.send('Hello');
});
</code></pre><p>아래 예제는 여러 디렉토리에서 정적 파일을 제공할 경우 다른 디렉토리보다 "./public"에 맨 처음 우선순위를 줍니다.
즉, 먼저 public 디렉토리를 살펴보고, 이후에 files를, 마지막으로 uploads를 살펴봅니다.
</p><pre class="js"><code>app.use(express.static(__dirname + '/public'));
app.use(express.static(__dirname + '/files'));
app.use(express.static(__dirname + '/uploads'));</code></pre></section><section><h3 id="app.engine">app.engine(ext, callback)</h3><p>템플릿 엔진의 <code>callback</code>을 <code>ext</code>로 등록합니다.
기본적으로 파일 확장자에 기반해 엔진을 구동합니다.
예를 들어, "foo.jade"파일을 호출할 때, Express는 내부적으로 아래 코드를 실행하며,
성능을 향상시키기 위해 이후의 호출들은 <code>require()</code>를 캐싱합니다.
</p><pre class="js"><code>app.engine('jade', require('jade').__express);
</code></pre><p>Express에서 간단히 쓸 수 있도록 <code>.__express</code> 기능을 제공 하지 않는 엔진을 사용할 경우,
이 방법을 이용하세요. 예를 들어 ".html"파일을 불러올 때 EJS 템플릿 엔진을 사용하고 싶다면, 아래와 같이 설정합니다.
</p><pre class="js"><code>app.engine('html', require('ejs').renderFile);
</code></pre><p>이 경우는 EJS가 Express에서 사용할 수 있게끔 <code>(path, options, callback)</code>를 파라미터로 가지는
<code>.renderFile()</code> 메소드를 제공하는 경우입니다.

그러나 사실 이 메소드는 내부적으로 <code>ejs.__express</code>를 부르고, ".ejs"확장자를 사용한다면
아무런 설정도 하지 않아도 됩니다. 
</p><p>어떤 템플릿 엔진는 이러한 방식을 따르지 않습니다. 
<a href="https://github.com/visionmedia/consolidate.js">consolidate.js</a>
라이브러리는 노드 진영에서 널리 쓰이는 템플릿 엔진들이 이러한 방식을 따르도록 감싸기 위해 만들어졌습니다.
</p><pre class="js"><code>var engines = require('consolidate');
app.engine('haml', engines.haml);
app.engine('html', engines.hogan);
// 어때요, 참 쉽죠?</code></pre></section><section><h3 id="app.param">app.param([name], callback)</h3><p>파라미터에 특정 로직을 반영합니다.
예를 들어, <code>:user</code>가 경로에 있을 때 <code>req.user</code>에 자동으로 유저 정보를 저장하거나, 파라미터 입력값의 유효성을 검사하는 등의 일을 수행할 수 있습니다. 
</p><p>아래는 <code>callback</code>이 얼마나 미들웨어와 비슷한지 보여줍니다.
비동기 작업을 지원하고, 파라미터의 값을 <code>id</code>로 제공하는 모습을 보여줍니다. 예를들어, <code>:user</code>에 hanul이 넘어오면, id의 값은 "hanul"이 됩니다.
유저 정보를 불러오고, <code>req.user</code>에 할당합니다. 오류가 발생하면 오류를 <code>next(err)</code>와 같이 넘깁니다. 
</p><pre class="js"><code>app.param('user', function(req, res, next, id){
  User.find(id, function(err, user){
    if (err) {
      next(err);
    } else if (user) {
      req.user = user;
      next();
    } else {
      next(new Error('failed to load user'));
    }
  });
});
</code></pre><p>다른 방법으론, <code>callback</code>만 넘기는 방법이 있는데, 이 경우에는 <code>app.param()</code> API를
변경할 수 있습니다.
예를 들어, <a href="http://github.com/visionmedia/express-params">express-params</a>는
아래 주어진 정규식으로 파라미터를 제한하는 콜백을 정의합니다.
</p><p>아래 예제는 두 번째 argument인 fn이 정규식인지 확인하고, 값이 정규식을 통과했을 경우에만 req.params[name]에 값을 반영한 뒤 다음으로 넘어갑니다.
</p><pre class="js"><code>app.param(function(name, fn){
  if (fn instanceof RegExp) {
    return function(req, res, next, val){
      var captures;
      if (captures = fn.exec(String(val))) {
        req.params[name] = captures;
        next();
      } else {
        next('route');
      }
    }
  }
});
</code></pre><p>이는 파라미터들의 유효성 검사 등을 할 때 효과적으로 쓰입니다.
</p><pre class="js"><code>app.param('id', /^\d+$/);

app.get('/user/:id', function(req, res){
  res.send('user ' + req.params.id);
});

app.param('range', /^(\w+)\.\.(\w+)?$/);

app.get('/range/:range', function(req, res){
  var range = req.params.range;
  res.send('from ' + range[1] + ' to ' + range[2]);
});</code></pre></section><section><h3 id="app.VERB">app.VERB(path, [callback...], callback)</h3><p><code>app.post()</code>와 같은 <code>app.VERB()</code> 메소드들은 앱의 각 <strong>VERB</strong>들에 대한 라우팅 기능을 제공합니다.
</p><p>아래는 가능한 가장 단순한 정의를 보여줍니다.
Express는 경로를 정규식으로 변환하며 이를 통해 요청을 정의된 라우터와 매치시킵니다.
참고로 쿼리 문자열은 이러한 매치를 수행하는 데 고려되지 <em>않습니다.</em>
예를 들어 "GET /"와 "GET /?name=tobi" 둘 다 이하 예제에서 라우트를 매칭시킵니다.    
</p><pre class="js"><code>app.get('/', function(req, res){
  res.send('hello world');
});
</code></pre><p>경로로는 정규식 또한 사용할 수 있습니다.
</p><pre class="js"><code>app.get(/^\/commits\/(\w+)(?:\.\.(\w+))?$/, function(req, res){
  var from = req.params[0];
  var to = req.params[1] || 'HEAD';
  res.send('commit range ' + from + '..' + to);
});
</code></pre><p>여러 콜백들을 넘길 수 있으며, 이를 통해 유효성 검사 등을 먼저 수행하는것과 같은 구성이 가능합니다.
</p><pre class="js"><code>app.get('/user/:id', user.load, function(){
  // ... 
})
</code></pre><p>라우트 하나에 공통으로 사용되는 여러가지 미들웨어가 있다면, <code>all</code>를 이용하여 이를 수행할 수 있습니다.
</p><pre class="js"><code>var middleware = [loadForum, loadThread];

app.route('/forum/:fid/thread/:tid')
.all(loadForum)
.all(loadThread)
.get(function() { //... });
.post(function() { //... });
</code></pre><p>위 예제는 GET이나 POST 요청이 오면 loadForum와 loadThread 미들웨어가 함께 실행되는 예제입니다. </p></section><section><h3 id="app.all">app.all(path, [callback...], callback)</h3><p>이 메소드는 모든 HTTP verb에서 <code>app.VERB()</code>와 같은 기능을 합니다. 
</p><p>이 메소드는 "전역"으로 사용되는 로직을 맵핑할 때 특히 유용합니다. 

예를 들어, 다음 라우트를 다른 모든 라우트 정의 위에 둔다면, 이 지점 이후부터 정의된 모든 라우트들은
인증을 필요로 하며 자동으로 유저 정보를 불러옵니다. 
</p><pre class="js"><code>app.all('*', requireAuthentication, loadUser);
</code></pre><p>또는 같은 기능을 아래와 같이 작성할 수도 있습니다.
</p><pre class="js"><code>app.all('*', requireAuthentication)
app.all('*', loadUser);
</code></pre><p>아래 예제는 앞의 것과 비슷하지만 오직 "/api"가 접두어로 오는 경로에만 적용됩니다. 
</p><pre class="js"><code>app.all('/api/*', requireAuthentication);</code></pre></section><section><h3 id="app.route">app.route(path)</h3><p>라우트 인스턴스를 반환합니다.
여기에 메소드 체인 형식으로 여러가지 미들웨어를 달 수 있습니다.
이는 같은 이름으로 중복해서 정의하는 라우트들이 있을 때 유용하게 사용됩니다.
</p><pre class="js"><code>var app = express();

app.route('/events')
.all(function(req, res, next) {
  // runs for all HTTP verbs first
  // think of it as route specific middleware!
})
.get(function(req, res, next) {
  res.json(...);
})
.post(function(req, res, next) {
  // maybe add a new event...
})
</code></pre></section><section><h3 id="app.locals">app.locals</h3><p>애플리케이션에 만들어진 모든 템플릿에 지역변수를 제공합니다. 
애플리케이션 레벨의 데이터나 템플릿에 helper 함수를 제공할 때 특히 유용합니다.
</p><pre class="js"><code>app.locals.title = 'My App';
app.locals.strftime = require('strftime');
app.locals.email = 'me@myapp.com';

app.locals.title
// => 'My App'

app.locals.email
// => 'me@myapp.com'</code></pre></section><section><h3 id="app.render">app.render(view, [options], callback)</h3><p><code>view</code>를 html로 생성한 문자열을 가져오는 콜백을 정의합니다.
이 것은 <code>res.render()</code>의 애플리케이션 레벨 변형이며, 같은 방법으로 동작합니다.
</p><pre class="js"><code>app.render('email', function(err, html){
  // ...
});

app.render('email', { name: 'Tobi' }, function(err, html){
  // ...
});</code></pre></section><section><h3 id="app.listen">app.listen()</h3><p>주어진 호스트와 포트 연결을 bind하고 listen합니다.
이 메소드는 노드의 <a href="http://nodejs.org/api/http.html#http_server_listen_port_hostname_backlog_callback">http.Server#listen()</a>와
동일합니다.
</p><pre class="js"><code>var express = require('express');
var app = express();
app.listen(3000);
</code></pre><p>사실 <code>express()</code>에 의해 반환되는 <code>app</code>은 콜백입니다.
노드의 http 서버로 넘기기 위해 디자인된 자바스크립트의 <code>function</code>이며,
이는 아래와 같이 HTTP와 HTTPS 프로토콜을 제공하는 두 서버에서 같은 역할을 수행할 수 있도록 정의할 수 있게 합니다.
</p><pre class="js"><code>var express = require('express');
var https = require('https');
var http = require('http');
var app = express();

http.createServer(app).listen(80);
https.createServer(options, app).listen(443);
</code></pre><p><code>app.listen()</code>은 단순이 편의성을 위헤 제공되는 메소드이며,
HTTPS를 사용하거나 HTTP, HTTPS 둘 다 사용하기 위해서는 위의 방법을 사용하세요.
</p><pre class="js"><code>app.listen = function(){
  var server = http.createServer(this);
  return server.listen.apply(server, arguments);
};</code></pre></section><h2>Request</h2><a name="request"></a><section><h3 id="req.params">req.params</h3><p>파라미터 경로에 맵핑되는 값들을 포함하는 객체입니다.
예를 들어, <code>/user/:name</code>가 설정되어 있을때, "name"의 값은 <code>req.params.name</code>로 사용 가능합니다.
기본값은 빈 객체인 <code>{}</code>입니다.
</p><pre class="js"><code>// GET /user/hanul
req.params.name
// => "hanul"
</code></pre><p>정규표현식이 사용되는 경우에는, <code>req.params[N]</code>를 사용할 수 있습니다.
<code>N</code>은 배열의 n번째를 의미합니다.
이는 이름이 정의되지 않은 와일드카드 매치나 `/file/*`과 같은 문자열 라우트에 사용될 수 있습니다.
</p><pre class="js"><code>// GET /file/javascripts/jquery.js
req.params[0]
// => "javascripts/jquery.js"</code></pre></section><section><h3 id="req.query">req.query</h3><p>쿼리 문자열들을 포함하고 있는 객체이며, 기본값은 빈 객체인 <code>{}</code>입니다.
</p><pre class="js"><code>// GET /search?q=tobi+ferret
req.query.q
// => "tobi ferret"

// GET /shoes?order=desc&shoe[color]=blue&shoe[type]=converse
req.query.order
// => "desc"

req.query.shoe.color
// => "blue"

req.query.shoe.type
// => "converse"</code></pre></section><section><h3 id="req.param">req.param(name)</h3><p>파라미터에 <code>name</code>의 값이 존재하는 경우 값을 반환합니다.
</p><pre class="js"><code>// ?name=hanul
req.param('name')
// => "hanul"

// POST name=hanul
req.param('name')
// => "hanul"

// /user/hanul for /user/:name 
req.param('name')
// => "hanul"
</code></pre><p>이는 다음과 같은 순서대로 살펴봅니다.</p><ul><li><code>req.params</code></li><li><code>req.body</code></li><li><code>req.query</code></li></ul></section><section><h3 id="req.route">req.route</h3><p>원본 path, 생성된 regexp, 파라미터 등 여러가지를 포함하는 객체입니다.
</p><pre class="js"><code>app.get('/user/:id?', function(req, res){
  console.log(req.route);
});
</code></pre><p>위 예제는 다음과 같이 출력합니다.
</p><pre class="js"><code>{ path: '/user/:id?',
  keys: [ { name: 'id', optional: true } ],
  regexp: /^\/user(?:\/([^\/]+?))?\/?$/i,
  params: [ id: '12' ] }</code></pre></section><section><h3 id="req.cookies">req.cookies</h3><p><code>cookieParser()</code> 미들웨어가 사용 될 때,
이 객체의 기본값은 <code>{}</code>입니다. 그렇지 않을 경우에는 user-agent에서 보낸 쿠키 정보를 포함합니다.
</p><pre class="js"><code>// Cookie: name=hanul
req.cookies.name
// => "hanul"
</code></pre><p>더 많은 정보나 기타 사항은 <a href="https://github.com/expressjs/cookie-parser">cookie-parser</a>을 참고하세요.</p></section><section><h3 id="req.signedCookies">req.signedCookies</h3><p><code>cookieParser()</code> 미들웨어가 사용 될 때,
이 객체의 기본값은 <code>{}</code>입니다. 그렇지 않을 경우에는 user-agent에서 보낸 암호화된 쿠키 정보를 포함합니다.

쿠키를 암호화 하는 것은 쿠키를 "숨기거나" 암호화 시키는 것을 의미하는 것이 아니라,
단지 쉽게 변경하는 것을 방지하기 위함입니다.
</p><pre class="js"><code>// Cookie: user=hanul.CP7AWaXDfAKIRfH49dQzKJx7sKzzSoPq7/AcBBRVwlI3
req.signedCookies.user
// => "hanul"
</code></pre><p>더 많은 정보나 기타 사항은 <a href="https://github.com/expressjs/cookie-parser">cookie-parser</a>을 참고하세요.</p></section><section><h3 id="req.get">req.get(field)</h3><p> 
대소문자를 구분하지 않는 request 헤더값을 불러옵니다.
<em>Referrer</em>과 <em>Referer</em>은 서로 이름이 틀리더라도 사용이 가능합니다.</p><pre class="js"><code>req.get('Content-Type');
// => "text/plain"

req.get('content-type');
// => "text/plain"

req.get('Something');
// => undefined
</code></pre><p><code>req.header(field)</code>로도 사용할 수 있습니다.</p></section><section><h3 id="req.accepts">req.accepts(types)</h3><p>주어진 <code>타입</code>이 허락되어 있는지 검사하고, 허락된 경우에는 가장 알맞는 타입을 반환합니다.
그렇지 않을 경우 <code>undefined</code>를 반환합니다. (이 경우에는 406 "Not Acceptable"이라고 응답해야 합니다.)
</p><p><code>req.accepts()</code>에 입력되는 <code>타입</code>은 "application/json"과 같은 하나의 mime 타입 문자열이나,
"json"과 같은 확장자 이름, 혹은 배열일 수 있습니다.
</p><pre class="js"><code>// Accept: text/html
req.accepts('html');
// => "html"

// Accept: text/*, application/json
req.accepts('html');
// => "html"
req.accepts('text/html');
// => "text/html"
req.accepts('json, text');
// => "json"
req.accepts('application/json');
// => "application/json"

// Accept: text/*, application/json
req.accepts('image/png');
req.accepts('png');
// => undefined

// Accept: text/*;q=.5, application/json
req.accepts(['html', 'json']);
req.accepts('html, json');
// => "json"
</code></pre><p>더 많은 정보나 기타 사항은 <a href="https://github.com/expressjs/accepts">accepts</a>를 참고하세요.</p></section><section><h3 id="req.acceptsCharsets">req.acceptsCharsets(charset, ...)</h3><p>입력된 <code>charset</code>이 허락되었는지 확인합니다.
</p><p>더 많은 정보나 기타 사항은 <a href="https://github.com/expressjs/accepts">accepts</a>를 참고하세요.</p></section><section><h3 id="req.acceptsLanguages">req.acceptsLanguages(lang, ...)</h3><p>입력된 <code>lang</code>이 허락되었는지 확인합니다.
</p><p>더 많은 정보나 기타 사항은 <a href="https://github.com/expressjs/accepts">accepts</a>를 참고하세요.</p></section><section><h3 id="req.acceptsEncodings">req.acceptsEncodings(encoding, ...)</h3><p>입력된 <code>encoding</code>이 허락되었는지 확인합니다.
</p><p>더 많은 정보나 기타 사항은 <a href="https://github.com/expressjs/accepts">accepts</a>를 참고하세요.</p></section><section><h3 id="req.is">req.is(type)</h3><p>요청이 입력된 "Content-Type" 헤더값을 포함하고 있는지 확인합니다.
</p><pre class="js"><code>// With Content-Type: text/html; charset=utf-8
req.is('html');
req.is('text/html');
req.is('text/*');
// => true

// When Content-Type is application/json
req.is('json');
req.is('application/json');
req.is('application/*');
// => true

req.is('html');
// => false
</code></pre><p>더 많은 정보나 기타 사항은 <a href="https://github.com/expressjs/type-is">type-is</a>를 참고하세요.</p></section><section><h3 id="req.ip">req.ip</h3><p>IP 주소를 반환합니다. ("trust proxy"가 활성화 되어 있을 경우에는 upstream 주소를 반환합니다.)

</p><pre class="js"><code>req.ip
// => "127.0.0.1"</code></pre></section><section><h3 id="req.ips">req.ips</h3><p>"trust proxy"가 `true`일때는, "X-Forwarded-For" IP 주소 목록를 해석하여 배열을 반환합니다.
그렇지 않은 경우에는 빈 배열을 반환합니다.

예를 들어, 값이 "client, proxy1, proxy2"라면,
<code>["client", "proxy1", "proxy2"]</code>라는 배열이 반환되며, "proxy2"가 가장 먼 down-stream입니다.</p></section><section><h3 id="req.path">req.path</h3><p>URL pathname을 반환합니다.
</p><pre class="js"><code>// example.com/users?sort=desc
req.path
// => "/users"</code></pre></section><section><h3 id="req.hostname">req.hostname</h3><p>"Host"의 헤더값로 부터 호스트를 반환합니다.
</p><pre class="js"><code>// Host: "example.com:3000"
req.host
// => "example.com"</code></pre></section><section><h3 id="req.fresh">req.fresh</h3><p>요청이 "fresh"인지 확인합니다. (Last-Modified 나 ETag가 여전히 같은지 확인합니다.)
</p><pre class="js"><code>req.fresh
// => true
</code></pre><p>더 많은 정보나 기타 사항은 <a href="https://github.com/visionmedia/node-fresh">fresh</a>를 참고하세요.</p></section><section><h3 id="req.stale">req.stale</h3><p>요청이 "stale"인지 확인합니다. (Last-Modified 나 ETag가 다른지 확인합니다.)

</p><pre class="js"><code>req.stale
// => true</code></pre></section><section><h3 id="req.xhr">req.xhr</h3><p>요청의 "X-Requested-With" 헤더값이 "XMLHttpRequest"(jQuery 등에서 사용하는)인지 확인합니다. 
</p><pre class="js"><code>req.xhr
// => true</code></pre></section><section><h3 id="req.protocol">req.protocol</h3><p>프로토콜이 "http"인지 "https"인지 확인하여 반환합니다.
"trust proxy" 속성이 활성화 되어있을 때는, "X-Forwarded-Proto" 헤더값도 신뢰합니다.
http를 제공하는 reverse proxy 뒤에서 실행하면, 이 속성은 활성화 됩니다.
</p><pre class="js"><code>req.protocol
// => "http"</code></pre></section><section><h3 id="req.secure">req.secure</h3><p>TLS로 요청되었는지 확인합니다. 이는 아래 코드의 단순한 표현입니다.
</p><pre class="js"><code>'https' == req.protocol;</code></pre></section><section><h3 id="req.subdomains">req.subdomains</h3><p>서브 도메인을 배열로 반환합니다.
</p><pre class="js"><code>// Host: "tobi.ferrets.example.com"
req.subdomains
// => ["ferrets", "tobi"]</code></pre></section><section><h3 id="req.originalUrl">req.originalUrl</h3><p><code>req.url</code>과 매우 흡사하지만, 내부적인 목적을 위해 <code>req.url</code>을 재작성 할 수 있도록 해줍니다.
</p><pre class="js"><code>// GET /search?q=something
req.originalUrl
// => "/search?q=something"</code></pre></section><h2>Response</h2><a name="response"></a><section><h3 id="res.status">res.status(code)</h3><p>체인화 할 수 있는 (Chainable) 노드의 <code>res.statusCode=</code>의 alias입니다. 
</p><pre class="js"><code>res.status(404).sendfile('path/to/404.png');</code></pre></section><section><h3 id="res.set">res.set(field, [value])</h3><p> 
헤더 <code>field</code>를 <code>value</code>로 설정합니다.
오브젝트를 여러 필드를 한꺼번에 설정하기 위해 오브젝트를 넘깁니다. </p><pre class="js"><code>res.set('Content-Type', 'text/plain');

res.set({
  'Content-Type': 'text/plain',
  'Content-Length': '123',
  'ETag': '12345'
})
</code></pre><p><code>res.header(field, [value])</code>라고도 알려져 있습니다.</p></section><section><h3 id="res.get">res.get(field)</h3><p> 
대소문자를 구분하지 않는 response 헤더값을 불러옵니다.</p><pre class="js"><code>res.get('Content-Type');
// => "text/plain"</code></pre></section><section><h3 id="res.cookie">res.cookie(name, value, [options])</h3><p>쿠키의 <code>name</code>을 <code>value</code> 설정하며,
이는 문자열이나 JSON으로 변환 된 오브젝트 입니다.
The <code>path</code> 옵션의 기본 값은 "/"입니다.
</p><pre class="js"><code>res.cookie('name', 'tobi', { domain: '.example.com', path: '/admin', secure: true });
res.cookie('rememberme', '1', { expires: new Date(Date.now() + 900000), httpOnly: true });
</code></pre><p><code>maxAge</code> 옵션은 "expires" 설정을 위한 것이며, 현재 시간을 밀리초로 설정 해 줍니다., 
아래 예제는 이전 예제와 같습니다.

</p><pre class="js"><code>res.cookie('rememberme', '1', { maxAge: 900000, httpOnly: true })
</code></pre><p>오브젝트는 JSON처럼 시리즈화(serialized) 되어 넘겨지며, 이것은 <code>bodyParser()</code> 미들웨어에 의해
자동적으로 파싱됩니다. 

</p><pre class="js"><code>res.cookie('cart', { items: [1,2,3] });
res.cookie('cart', { items: [1,2,3] }, { maxAge: 900000 });
</code></pre><p>Signed 쿠키는 또한 이 메소드를 통해 지원됩니다.
단순히 <code>signed</code> 옵션을 넘기세요.
주어진 <code>res.cookie()</code>가 값을 sign 하기 위해
<code>cookieParser(secret)</code>로 넘겨진 비밀(secret)을 사용 할 것입니다.

</p><pre class="js"><code>res.cookie('name', 'tobi', { signed: true });
</code></pre><p>이후, <a href="#req.signedCookies">req.signedCookie</a> 오브젝트를 통해 이 값에 접근 할 수 있습니다.</p></section><section><h3 id="res.clearCookie">res.clearCookie(name, [options])</h3><p>쿠키 <code>name</code>를 클리어 해 줍니다. 
경로 옵션의 기본 값은 "/"입니다.
</p><pre class="js"><code>res.cookie('name', 'tobi', { path: '/admin' });
res.clearCookie('name', { path: '/admin' });</code></pre></section><section><h3 id="res.redirect">res.redirect([status], url)</h3><p>선택적 <code>status</code>코드와 주어진 <code>url</code>로 우회합니다.
기본 값은 302 "Found" 입니다.
</p><pre class="js"><code>res.redirect('/foo/bar');
res.redirect('http://example.com');
res.redirect(301, 'http://example.com');
res.redirect('../login');
</code></pre><p>Express는 여러 우회 방법을 지원합니다. 
완전히 qualified 된 URI가 다른 사이트로 우회 하려면,
</p><pre class="js"><code>res.redirect('http://google.com');
</code></pre><p>두 번째 방법은 경로이름과 관계된 우회 방법입니다.
예를 들면 <code>http://example.com/admin/post/new</code>에 있고
그 우회로가 <code>/admin</code>라면, <code>http://example.com/admin</code>로 접근 시켜 줍니다.
</p><pre class="js"><code>res.redirect('/admin');
</code></pre><p>그 다음 방법은 애플리케이션의 <code>mount</code> 포인트를 사용한 방법입니다.
예를 들어, 만약 <code>/blog</code>에 마운트 된 블로그 애플리케이션이 있다면, 이상적으로
이것은 어디에서 마운트 되었는지의 정보를 가지고 있지 않으며,
이는 <code>/admin/post/new</code>의 우회로가 단순히 <code>http://example.com/admin/post/new</code>라는 우회를
넘겨주게 되며, 이는 <code>http://example.com/blog/admin/post/new</code>로 접근 시켜 줍니다.

</p><pre class="js"><code>res.redirect('admin/post/new');
</code></pre><p>경로 이름으로 우회하는 방법 또한 가능합니다.
만약 <code>http://example.com/admin/post/new</code>에 있다면 그 우회로는 
<code>http//example.com/admin/post</code>로 접근 시켜 줍니다.
</p><pre class="js"><code>res.redirect('..');
</code></pre><p>. 
마지막 특별한 방법은 <code>back</code> 우회법인데, Referer (혹은 Referrer)로 다시 우회 시켜주는 방법이며,
값이 지정 되어 있지 않을 때, 기본 값은 <code>/</code>입니다.</p><pre class="js"><code>res.redirect('back');

</code></pre></section><section><h3 id="res.location">res.location</h3><p>위치(location) 헤더를 설정합니다.
</p><pre class="js"><code>res.location('/foo/bar');
res.location('foo/bar');
res.location('http://example.com');
res.location('../login');
res.location('back');
</code></pre><p><code>res.redirect()</code>와 같이, 같은 종류의 <code>urls</code>를 사용 할 수 있습니다.
</p><p>For example, 
예를 들어, 애플리케이션이 <code>/blog</code>에 마운트 되어 있으면
아래는 <code>location</code> 헤더를 <code>/blog/admin</code>로 설정 해 줍니다.
</p><pre class="js"><code>res.location('admin')</code></pre></section><section><h3 id="res.send">res.send([body|status], [body])</h3><p>Response를 보냅니다.
</p><pre class="js"><code>res.send(new Buffer('whoop'));
res.send({ some: 'json' });
res.send('<p>some html</p>');
res.send(404, 'Sorry, we cannot find that!');
res.send(500, { error: 'something blew up' });
res.send(200);
</code></pre><p>이 메소드는 
미리 정의 되고, 오토메틱 <em>HEAD</em>과 HTTP cache freshness 지원을 제공하고 있지 않는 한
자동적으로 Content-Length를 할당하는 것과 같은 단순 non-streaming response의
유용한 task를 수행하는 데에 사용됩니다.
</p><p>When a <code>Buffer</code> is given
<code>Buffer</code>가 주어 질 때, Content-Type은
아래와 같이 미리 정의 되지 않는 한,
"application/octet-stream"로 설정됩니다. 

</p><pre class="js"><code>res.set('Content-Type', 'text/html');
res.send(new Buffer('<p>some html</p>'));
</code></pre><p><code>String</code>가 주어 질 때, Content-Type은
기본적으로 "text/html"로 설정됩니다.
</p><pre class="js"><code>res.send('<p>some html</p>');
</code></pre><p><code>Array</code>나 <code>Object</code>가 주어 질 때,
Express는 JSON representation에 응답합니다.
</p><pre class="js"><code>res.send({ user: 'tobi' })
res.send([1,2,3])
</code></pre><p>마지막으로 <code>Number</code>가 미리 언급 된 body없이 주어 질 때,
response body 문자열이 할당 됩니다.
예를 들어, 200은 "OK"라고 응답(respond)하며,
404는 "Not Found" 등으로 나타납니다.

</p><pre class="js"><code>res.send(200)
res.send(404)
res.send(500)</code></pre></section><section><h3 id="res.json">res.json([status|body], [body])</h3><p>JSON response를 보냅니다.
이 메소드는 오브젝트나 배열이 넘겨 질 때, <code>res.send()</code>와 동일하나,
엄밀하게는 JSON에서는 허용되지 않지만 
오브젝트가 아닌 것들의 (null, undefined, 등)의 explicit한 JASON 변환 등에 사용됩니다.

</p><pre class="js"><code>res.json(null)
res.json({ user: 'tobi' })
res.json(500, { error: 'message' })</code></pre></section><section><h3 id="res.jsonp">res.jsonp([status|body], [body])</h3><p>Send a JSON response with JSONP support. 
JSON response와 JSONP support를 보냅니다.
이 메소드는 <code>res.json()</code>과 동의하나, JSNOP 콜백 support의 opts-in입니다.
</p><pre class="js"><code>res.jsonp(null)
// => null

res.jsonp({ user: 'tobi' })
// => { "user": "tobi" }

res.jsonp(500, { error: 'message' })
// => { "error": "message" }
</code></pre><p>기본 값으로, JSONP 콜백 이름은 단순히 <code>callback</code>이지만,
이는 <a href="#app-settings">jsonp callback name</a> 설정으로 변경 할 수 있습니다.
아래는 같은 코드를 이용한 JSNOP response 예제입니다.
</p><pre class="js"><code>// ?callback=foo
res.jsonp({ user: 'tobi' })
// => foo({ "user": "tobi" })

app.set('jsonp callback name', 'cb');

// ?cb=foo
res.jsonp(500, { error: 'message' })
// => foo({ "error": "message" })</code></pre></section><section><h3 id="res.type">res.type(type)</h3><p>Content-Type을 <code>type</code> mime lookup으로 설정하거나,
"/"가 존재 할 때, Content-Type는 단순히 이 그 자체의 값으로 설정됩니다.
</p><pre class="js"><code>res.type('.html');
res.type('html');
res.type('json');
res.type('application/json');
res.type('png');</code></pre></section><section><h3 id="res.format">res.format(object)</h3><p>요청 Accept 헤더 필드에 컨텐트 타협(content-negotiation)가 있을 경우 이를 수행합니다.
이 메소드는 quality 값의 순서로 이루어진 수용 할 수 있는 종류(accpetable types)의 배열인 <code>req.accepted</code>를 사용하고,
그렇지 않을 경우에는 첫 콜백이 호출됩니다.
아무 것도 매칭 되지 않을 경우는 서버는 406 "Not Acceptable"로 응답하거나, <code>default</code> 콜백을 호출합니다.
</p><p>콜백이 선택 될 경우 컨텐트 타협(content-negotiation)이 설정되나,
이는 콜백 내에서 <code>res.set()</code>나 <code>res.type()</code> 등을 이용하여 수정 할 수 있습니다.
</p><p>아래 예제는 Accept 헤더 필드가 "application/json"나 "*/json"로 설정 될 때
<code>{ "message": "hey" }</code>로 응답하나, 만일 "*/*"이 주어지면 "hey"라고 응답합니다.

</p><pre class="js"><code>res.format({
  'text/plain': function(){
    res.send('hey');
  },
  
  'text/html': function(){
    res.send('<p>hey</p>');
  },
  
  'application/json': function(){
    res.send({ message: 'hey' });
  }
});
</code></pre><p>캐논 형식의(Canonicalized) MIME 타입 이외에도, 
이러한 타입과 맵핑 된 extnames도 사용 할 수 있으며, 이는 더 간략한 구현을 제공합니다.
</p><pre class="js"><code>res.format({
  text: function(){
    res.send('hey');
  },
  
  html: function(){
    res.send('<p>hey</p>');
  },
  
  json: function(){
    res.send({ message: 'hey' });
  }
});</code></pre></section><section><h3 id="res.attachment">res.attachment([filename])</h3><p>Content-Disposition 헤더 필드를 "attachment"로 설정합니다.
만일 <code>filename</code>가 주어 지면, Content-Type은 자동적으로 extname에 근거 하여
<code>res.type()</code>을 통해 설정 되며, Content-Disposition의 
"filename="가 설정 됩니다.
</p><pre class="js"><code>res.attachment();
// Content-Disposition: attachment

res.attachment('path/to/logo.png');
// Content-Disposition: attachment; filename="logo.png"
// Content-Type: image/png</code></pre></section><section><h3 id="res.sendfile">res.sendfile(path, [options], [fn])</h3><p>주어진 <code>path</code>의 파일을 전송합니다.</p><p>파일 이름의 확장자에 근거 하여 자동적으로 Content-Type response 헤더 필드를 기본 값으로 합니다.
파일 전송이 완료 되거나 에러 발생 시,  <code>fn(err)</code> 콜백이 호출됩니다.
</p><p>옵션:</p><ul><li><code>maxAge</code> 밀리초 형태, 기본 값은 0</li><li><code>root</code> 관계 된 파일 이름을 위한 라우트 디렉토리</li></ul><p>이 메소드는 아래 예제에 보여 지는 것처럼, 파일을 서빙(serving)하기 위한 fine-grained 지원을 제공합니다.
</p><pre class="js"><code>app.get('/user/:uid/photos/:file', function(req, res){
  var uid = req.params.uid
    , file = req.params.file;
    
  req.user.mayViewFilesFrom(uid, function(yes){
    if (yes) {
      res.sendfile('/uploads/' + uid + '/' + file);
    } else {
      res.send(403, 'Sorry! you cant see that.');
    }
  });
});
</code></pre><p>더 많은 문서를 보거나, 문제가 있을 경우에는 <a href="https://github.com/visionmedia/send">send</a>을 참고하세요.</p></section><section><h3 id="res.download">res.download(path, [filename], [fn])</h3><p><code>path</code>에 있는 파일을 "attachment"로 전송합니다. 
대부분 브라우저는 유저에게 다운로드를 유도합니다.
브라우저 다이얼로그에 나타나기도 하게 알려 진 Content-Disposition "filename=" 파라미터는
기본적으로 <code>path</code>로 설정되며, 
이에 직접 <code>filename</code> override를 제공 할 수 있습니다.
</p><p>에러가 발생하거나 전송이 완료 되면,
optional 콜백인 <code>fn</code>이 호출됩니다.
이 메소드는 파일을 전송하기 위해 <a href="#res.sendfile">res.sendfile()</a>을 사용합니다.
</p><pre class="js"><code>res.download('/report-12345.pdf');

res.download('/report-12345.pdf', 'report.pdf');

res.download('/report-12345.pdf', 'report.pdf', function(err){
  if (err) {
    // handle error, keep in mind the response may be partially-sent
    // so check res.headersSent
  } else {
    // decrement a download credit etc
  }
});</code></pre></section><section><h3 id="res.links">res.links(links)</h3><p>"Link" response 헤더 필드를 채우기 위해, 주어진 <code>links</code>에 join합니다.
</p><pre class="js"><code>res.links({
  next: 'http://api.example.com/users?page=2',
  last: 'http://api.example.com/users?page=5'
});
</code></pre><p>는 아래의 결과를 만듭니다:</p><pre><code>Link: &lt;http://api.example.com/users?page=2&gt;; rel="next", 
      &lt;http://api.example.com/users?page=5&gt;; rel="last"</code></pre></section><section><h3 id="res.locals">res.locals</h3><p>Response 지역변수는 요청으로 확장 되며, 
요청(request)/응답(response) cycle 동안 view(s) rendered에 사용 가능 합니다.
그렇지 않으면, 이 API는 <a href="#app.locals">app.locals</a>와 동일합니다.
</p><p>이 오브젝트는 요청 경로 이름, 인증 된 유저, 유저 설정 등의 요청 레벨의 정보를 노출 할 때 유용합니다. 
</p><pre class="js"><code>app.use(function(req, res, next){
  res.locals.user = req.user;
  res.locals.authenticated = ! req.user.anonymous;
  next();
});</code></pre></section><section><h3 id="res.render">res.render(view, [locals], callback)</h3><p>. 
<code>view</code>과 render된 문자열과 응답하는 콜백을 render합니다. 
<code>next(err)</code>가 내부적으로 호출되면 에러가 발생합니다.
콜백이 제공 되면, 가능한 에러와 render된 문자열 둘 다 넘겨지며, 자동 처리된 응답은 수행 되지 않습니다.</p><pre class="js"><code>res.render('index', function(err, html){
  // ...
});

res.render('user', { name: 'Tobi' }, function(err, html){
  // ...
});</code></pre></section><h2>Router</h2><a name="router"></a><section><h3 id="router">Router()</h3><p>라우터는 미들웨어와 라우트들의 독립 된 인스턴스 입니다.
라우터는 미들웨어와 라우팅을 수행 할 수 있는 "mini" 애플리케이션이라고 생각 될 수 있습니다.
모든 express 애플리케이션은 빌트인 앱 라우터를 가지고 있습니다. 
</p><p>라우터는 미들웨어처럼 행동하며, 앱이나 다른 라우터에 의해 ".use()'d" 될 수 있습니다.
</p><p>"express.Router()"을 사용하여 새 라우터를 생성합니다.
</p><pre class="js"><code>var router = express.Router([options]);
</code></pre><p>아래 옵션은 라우터의 라우트를 매칭하는 역할을 수정하기 위한 optional 오브젝트입니다.
</p><ul><li><code>caseSensitive </code>예를 들어 "/Foo" 와 "/foo"를 같게 처리하던 기본 적으로 비활성화 되어 있는 대소문자 구분을 활성화 시킵니다. </li><li><code>strict </code>Strict 라우팅을 활성화 시킵니다. 기본 적으 라우터는 "/foo"를 "/foo/" 같게 처리합니다.</li></ul><p>라우터는 미들웨어와, 애플리케이션 처럼 http VERB 라우트를 가질 수 있습니다. 
</p><pre class="js"><code>// invoked for any requests passed to this router
router.use(function(req, res, next) {
  // .. some logic here .. like any other middleware
  next();
});

// will handle any request that ends in /events
// depends on where the router is "use()'d"
router.get('/events', function(req, res, next) {
  // ..
});
</code></pre><p>이는 파일이나 mini앱의 라우트를 분리시키는 방법으로 특정 라우트 url을 위한 라우터를 사용 할 수 있습니다. 
</p><pre class="js"><code>// only requests to /calendar/* will be sent to our "router"
app.use('/calendar', router);
</code></pre></section><section><h3 id="router.use">router.use([path], function)</h3><p>주어진 <code>function</code> 미들웨어와 optional 마운트인 <code>path</code>를 사용합니다. 기본 값은 "/"입니다.
</p><p>request들은 당신이 정의한 첫번째 미들웨어에서 시작하며, 그들이 매칭하는 각 경로를 처리하며 미들웨어 스택 아래로 아동합니다. 
</p><pre class="js"><code>var express = require('express');
var app = express();
var router = express.Router();

// simple logger for this router's requests
// all requests to this router will first hit this middleware
router.use(function(req, res, next) {
  console.log('%s %s %s', req.method, req.url, req.path);
  next();
});

// this will only be invoked if the path ends in /bar
router.use('/bar', function(req, res, next) {
  // ... maybe some additional /bar logging ...
  next();
});

// always invoked
router.use(function(req, res, next) {
  res.send('Hello World');
});

app.use('/foo', router);

app.listen(3000);
</code></pre><p>"mount"경로는 stripped되며, middleware <code>function</code>에 보이지 <strong>않습니다.</strong>
이 특징의 가장 큰 효과는 마운트 된 미들웨어는 "prefix" 경로 이름에 상관 없이 코드의 변환 없이도 실행 할 수 있다는 것입니다. 
</p><p><code>router.use()</code>를 사용하는 "정의 된" 미들웨어의 순서는 매우 중요하며, 그 미들웨어들은 순서대로 호출됩니다.
그러므로 이는 미들웨어의 우선순위를 정의합니다.
예를 들어, logger는 사용 하는 미들웨어의 가장 첫번째이며, 매 요청을 로깅합니다.
</p><pre class="js"><code>var logger = require('morgan');

router.use(logger());
router.use(express.static(__dirname + '/public'));
router.use(function(req, res){
  res.send('Hello');
});
</code></pre><p>만일 static 파일을 위한 로깅 요청을 무시하고, 계속해서 라우트를 로깅하고 싶다면,
미들웨어는 <code>logger()</code> 이후에 정의되며, 단순히 위의 <code>static()</code>로 이동합니다.
</p><pre class="js"><code>router.use(express.static(__dirname + '/public'));
router.use(logger());
router.use(function(req, res){
  res.send('Hello');
});
</code></pre><p>다른 예제는, 여러 디렉토리로 부터 파일을 serving하는 것입니다. 이는 다른 것으로 보다도 "./public"에게 우선순위를 줍니다.
</p><pre class="js"><code>app.use(express.static(__dirname + '/public'));
app.use(express.static(__dirname + '/files'));
app.use(express.static(__dirname + '/uploads'));</code></pre></section><section><h3 id="router.param">router.param([name], callback)</h3><p>논리(logic)을 라우트 파라미터로 맵핑합니다.
예를 들어 라우트 경로 안에 <code>:user</code>가 존재하가면, 류저 로딩 논리를 자동적으로 <code>req.user</code>을 라우트에 제공하기 위하거나
입력 파라미터 값의 유효성 검사를 수행하기 위해 맵핑 할 수 있습니다. 
</p><p>아래는 어떻게 <code>callback</code>가 미들웨어 같이 행동하여 asnc operation을 지원하는 지를 보여줍니다.
그러나 이는 파라미터의 부가적인 값을 제공합니다. (여기에서는 <code>id</code>).
그 후 유저를 불러오려는 시도가 수행되며, 이는 <code>req.user</code>를 할당합니다.
그렇지 않은 경우에는 <code>next(err)</code>로 에러를 넘깁니다.

</p><p><code>next</code>가 이름있는 파라미터 핸들러(named parameter handler) 안에 에러가 호출 되지 않는다면,
실행하기 위한 이름이 있는 파라미터 함수(named paramter funcion)를 유발하는 라우트가 실행 됩니다.
</p><pre class="js"><code>router.param('user', function(req, res, next, id){
  User.find(id, function(err, user){
    if (err) {
      return next(err);
    }
    else if (!user) {
      return next(new Error('failed to load user'));
    }
    
    req.user = user;
    next();
  });
});

// this route uses the ":user" named parameter
// which will cause the 'user' param callback to be triggered
router.get('/users/:user', function(req, res, next) {
  // req.user WILL be defined here
  // if there was an error, normal error handling will be triggered
  // and this function will NOT execute
});
</code></pre><p>그 대신에 <code>callback</code>만을 넘길 수 있으며, 이 경우는 <code>router.param()</code> API를 수정 할 수 있는 기회가 생깁니다.
예를 들어, <a href="http://github.com/visionmedia/express-params">express-params</a>는 파라미터를 주어진 정규식에 제한하게 해주는 
아래 콜백을 정의합니다. 

</p><p>아래 예제는 두번째 argument가 정규식인지 확인하며, "user" param 예제 처럼 행동하는 콜백을 반환하는 것을 보여주는
응용 예제입니다.
</p><pre class="js"><code>router.param(function(name, fn){
  if (fn instanceof RegExp) {
    return function(req, res, next, val){
      var captures;
      if (captures = fn.exec(String(val))) {
        req.params[name] = captures;
        next();
      } else {
        next('route');
      }
    }
  }
});
</code></pre><p>이 메소드는 파라미터의 유효성을 검사하거나 캡쳐 그룹(capture groups)을 제공하기 위해 파싱하는 데에도 유용합니다.
</p><pre class="js"><code>router.param('id', /^\d+$/);

router.get('/user/:id', function(req, res){
  res.send('user ' + req.params.id);
});

router.param('range', /^(\w+)\.\.(\w+)?$/);

router.get('/range/:range', function(req, res){
  var range = req.params.range;
  res.send('from ' + range[1] + ' to ' + range[2]);
});
</code></pre><p><code>router.use()</code> 메소드는 또한 이름이 있는 파라미터(named parameter)을 지원하여, 다른 라우터를 위한
마운트 포인트가 이름 있는 파라미터를 사용하여 프리로딩 하는 에게 이득이 되도록 해줍니다.
</p></section><section><h3 id="router.route">router.route(path)</h3><p>HTTP verg와 optional 미들웨어를 다루는 데 사용 될 수 있는 싱글 라우트의 인스턴스를 반환합니다.
<code>router.route()</code>를 사용 하는 것은 중복되는 라우트 이름과 오타에서 나오는 에러를 방지하지 위한
접근 법으로 권장됩니다.

</p><p>이전의 <code>router.param()</code>를 만드는 예제로부터,
어떻게 <code>router.route()</code>가 여러 HTTP verb handler를 쉽게 명시 해 줄 수 있게 도와주는지 볼 수 있습니다.
</p><pre class="js"><code>var router = express.Router();

router.param('user_id', function(req, res, next, id) {
  // sample user, would actually fetch from DB, etc...
  req.user = {
    id: id,
    name: 'TJ'
  };
  next();
});

router.route('/users/:user_id')
.all(function(req, res, next) {
  // runs for all HTTP verbs first
  // think of it as route specific middleware!
})
.get(function(req, res, next) {
  res.json(req.user);
})
.put(function(req, res, next) {
  // just an example of maybe updating the user
  req.user.name = req.params.name;
  // save user ... etc
  res.json(req.user);
})
.post(function(req, res, next) {
  next(new Error('not implemented'));
})
.delete(function(req, res, next) {
  next(new Error('not implemented'));
})
</code></pre><p>이 방법은 싱글 '/users/:user_id' 경로를 재사용하며, 여러 HTTP verb를 위한 핸들러를 더해줍니다.</p></section><section><h3 id="router.VERB">router.VERB(path, [callback...], callback)</h3><p><code>router.VERB()</code>메소드는 Express의 라우팅 기능을 제공하며, <strong>VERB</strong>는
<code>router.post()</code>와 같은 HTTP verb 중 하나입니다.
여러 콜백이 주어지고, 동등하게 처리되며, 한 가지 예외 사항을 제외하고는 미들웨어처럼 행동합니다.
이 예외 사항은 이러한 콜백이 남은 라우트 콜백을 우회하기 위하여 <code>next('route')</code>를 호출한다는 것입니다.
이러한 방법은 라우트 위의 pre-conditions를 수행하고 매칭 된 라우트와 진행 할 필요가 없을 경우
다음 라우트들에 컨트롤을 넘기기 위하여 사용 될 수 있습니다.
</p><p>아래 예제는 가장 단순한 라우트 정의를 보여줍니다.
Express는 경로 문자열을 정규식으로 변환해주며, 내부적으로 들어오는 요청을 매칭합니다.
쿼리 문자열은 이러한 매칭을 수행 할 때 고려되지 <em>않으며</em>, 예를 들어 
"GET /"는 "GET /?name=tobi"와 마찬 가지로 다음 라우트를 매칭합니다.

</p><pre class="js"><code>router.get('/', function(req, res){
  res.send('hello world');
});
</code></pre><p>정규식 또한 사용 될 수 있으며, 특별한 제한 사항이 있는 경우 유용합니다.
예를 들어 아래는  "GET /commits/71dbb9c..4c084f9" 뿐만 아니라 "GET /commits/71dbb9c"도 매칭시킵니다.

</p><pre class="js"><code>router.get(/^\/commits\/(\w+)(?:\.\.(\w+))?$/, function(req, res){
  var from = req.params[0];
  var to = req.params[1] || 'HEAD';
  res.send('commit range ' + from + '..' + to);
});</code></pre></section><h2>Middleware</h2><a name="middleware"></a><p> 
4.x부터, Express는 Connect에 종속되지 않습니다.
이전에 포함되었던 모든 미들웨어는 이제 분리되었습니다.</p><p><a href="https://github.com/senchalabs/connect#middleware">the list of middleware</a>를 참고해 주세요.</p></div></section><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-38025412-4', 'auto');
ga('send', 'pageview');
</script><a id="top" href="#"><img src="/images/arrow.png"></a></body></html>